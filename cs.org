#+TITLE: CS

* Structure and Interpretation of Computer Programs
:PROPERTIES:
:SOURCE: https://melpa.org/#/sicp https://github.com/sarabander/sicp-pdf https://github.com/sarabander/sicp
:END:
:LOGBOOK:
CLOCK: [2020-11-12 Thu 12:07]--[2020-11-12 Thu 16:07] =>  4:00
CLOCK: [2020-11-06 Fri 09:59]--[2020-11-06 Fri 12:59] =>  3:00
CLOCK: [2020-11-04 Wed 08:55]--[2020-11-04 Wed 11:55] =>  3:00
CLOCK: [2020-11-01 Sun 10:03]--[2020-11-01 Sun 13:03] =>  3:00
CLOCK: [2020-10-30 Fri 10:05]--[2020-10-30 Fri 14:05] =>  4:00
CLOCK: [2020-10-27 Tue 12:13]--[2020-10-27 Tue 15:13] =>  3:00
CLOCK: [2020-10-25 Sun 13:53]--[2020-10-25 Sun 16:53] =>  3:00
CLOCK: [2020-10-22 Thu 13:46]--[2020-10-22 Thu 16:46] =>  3:00
CLOCK: [2020-10-18 Sun 13:13]--[2020-10-18 Sun 16:13] =>  3:00
CLOCK: [2020-10-14 Wed 12:29]--[2020-10-14 Wed 15:29] =>  3:00
CLOCK: [2020-10-12 Mon 10:09]--[2020-10-12 Mon 13:09] =>  3:00
CLOCK: [2020-10-09 Fri 14:17]--[2020-10-09 Fri 16:17] =>  2:00
CLOCK: [2020-10-04 Sun 10:18]--[2020-10-04 Sun 12:18] =>  2:00
CLOCK: [2019-10-06 Sun 15:10]--[2019-10-06 Sun 17:10] =>  2:00
CLOCK: [2019-10-01 Tue 17:57]--[2019-10-01 Tue 20:57] =>  3:00
CLOCK: [2019-09-22 Sun 19:50]--[2019-09-22 Mon 20:50] =>  1:00
CLOCK: [2019-09-22 Sun 18:30]--[2019-09-22 Sun 19:30] =>  1:00
CLOCK: [2019-09-16 Mon 18:14]--[2019-09-16 Mon 20:14] =>  2:00
CLOCK: [2019-09-13 Fri 15:03]--[2019-09-13 Fri 16:03] =>  1:00
CLOCK: [2019-09-12 Thu 16:20]--[2019-09-12 Thu 18:20] =>  2:00
CLOCK: [2019-09-10 Tue 14:50]--[2019-09-10 Tue 16:50] =>  2:00
:END:

[[./sicp-cover.jpg]]

** 1 Building Abstractions with Procedures
*** 1.1 The Elements of Programming
**** 1.1.1 Expressions
**** 1.1.2 Naming and the Environment
***** Read-Eval-Print Loop                                        :drill:
SCHEDULED: <2022-03-04 Fri>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       2D416CA8-BE20-44A9-864E-EB8FFA238594
:DRILL_LAST_INTERVAL: 636.4045
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-06-06 Sat 12:58]
:END:

cs: How is called a python/lisp *interpreter input cycle*?

****** Answer

A Read-Eval-Print Loop

***** Define a Variable in Elisp                                  :drill:
SCHEDULED: <2023-01-22 Sun>
:PROPERTIES:
:ID:       88902983-949C-4B13-BA73-18FE15B5FBFE
:DRILL_LAST_INTERVAL: 831.7489
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.86
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-10-12 Mon 09:58]
:END:

elisp: *Define a variable* with <[defconst]>, <[defvar]> or <[setq]>

***** Define a Variable in Scheme                                 :drill:
SCHEDULED: <2021-11-28 Sun>
:PROPERTIES:
:ID:       A7ADBEAE-CF04-4C46-A9BD-B56A99E44168
:DRILL_LAST_INTERVAL: 533.514
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-06-12 Fri 15:23]
:END:

scheme: *Define a variable* with <[(define NAME VALUE)]>

**** 1.1.3 Evaluating Combinations
***** Special Forms                                               :drill:
SCHEDULED: <2021-09-20 Mon>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:SOURCE: https://www.gnu.org/software/emacs/manual/html_node/elisp/Special-Forms.html
:ID:       2F79DFE4-7B97-4A45-A01C-815C4E5E3EE6
:DRILL_LAST_INTERVAL: 253.844
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 15
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.533
:DRILL_EASE: 1.92
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-09 Sat 08:39]
:END:

lisp: <[*Special Forms*]> are <[functions that don't *evaluate* all of their
arguments]>

**** 1.1.4 Compound Procedures
***** Function vs Procedure                                       :drill:
SCHEDULED: <2022-06-09 Thu>
:PROPERTIES:
:SOURCE: https://blog.kotlin-academy.com/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87 https://en.wikipedia.org/wiki/Subroutine#Language_support_2
:ID:       7ED81C54-AD66-4083-ACAE-37A82F6C4A23
:DRILL_LAST_INTERVAL: 623.1051
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.091
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-09-24 Thu 13:34]
:END:

cs: A *subroutine* that returns a value is usually called a <[Function]>
cs: A *subroutine* that doesn't return a value is usually called a <[Procedure]>

***** Anonymous Function aka Lambda                               :drill:
SCHEDULED: <2022-02-25 Fri>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       CEDD1A92-C15E-4BC0-9C75-8F4B71DC3ACE
:DRILL_LAST_INTERVAL: 631.1881
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-06-04 Thu 11:49]
:END:

cs: <[Anonymous Function]> aka <[Lambda]>

***** Scheme Named Function Definition                            :drill:
SCHEDULED: <2021-02-12 Fri>
:PROPERTIES:
:SOURCE: https://www.gnu.org/software/guile/manual/html_node/Creating-a-Procedure.html#Creating-a-Procedure https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Lambda-Expressions.html#Lambda-Expressions
:ID:       732F37AC-1DF9-4165-8055-3A2A67674B99
:DRILL_LAST_INTERVAL: 37.33
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 34
:DRILL_FAILURE_COUNT: 7
:DRILL_AVERAGE_QUALITY: 3.529
:DRILL_EASE: 1.9
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-06 Wed 19:01]
:END:

scheme: prototype: Define a named function:
<[(define NAME (lambda (ARGS...) ...))]>
OR shorter version:
<[(define (NAME ARGS...) ...)]>

***** Lambda Definition                                           :drill:
SCHEDULED: <2021-07-04 Sun>
:PROPERTIES:
:SOURCE: https://www.gnu.org/software/guile/manual/html_node/Creating-a-Procedure.html#Creating-a-Procedure https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Lambda-Expressions.html#Lambda-Expressions
:ID:       65190513-558A-4D8B-ACB3-160894F6730B
:DRILL_LAST_INTERVAL: 456.2115
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-04-04 Sat 12:44]
:END:

lisp: prototype: Define a Lambda with <[(lambda (args...) expressions)]>

****** Note

This is common to most lisp based languages

***** Elisp Named Function Definition                             :drill:
SCHEDULED: <2021-01-28 Thu>
:PROPERTIES:
:ID:       8F8D9A03-5564-4F52-A1C1-E383CFCC965E
:DRILL_LAST_INTERVAL: 71.6844
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 33
:DRILL_FAILURE_COUNT: 6
:DRILL_AVERAGE_QUALITY: 3.636
:DRILL_EASE: 2.1
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-11-17 Tue 12:26]
:END:

elisp: prototype: Define a named function:
<[(defun NAME (args...) [docstring] [declare] [interactive] ...)]>

***** Elisp Named Function Definition Declare                     :drill:
SCHEDULED: <2021-03-05 Fri>
:PROPERTIES:
:ID:       FA1F46C0-91E9-466D-B831-2F1418A1A93B
:DRILL_LAST_INTERVAL: 43.3018
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 16
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.624
:DRILL_EASE: 2.14
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-21 Thu 09:29]
:END:

elisp: In ~(defun NAME (args...) [docstring] [declare] [interactive])~ *declare*
can be used to add <[properties]> to the function

****** Example

(interactive-only value)
(obsolete current-name when)

***** Elisp Named Function Definition Interactive                 :drill:
SCHEDULED: <2022-01-07 Fri>
:PROPERTIES:
:ID:       ACC72965-D448-41E9-AF6F-8FAE46D76D68
:DRILL_LAST_INTERVAL: 382.3501
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 12
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.75
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-12-21 Mon 12:32]
:END:

elisp: In ~(defun NAME (args...) [docstring] [declare] [interactive])~
*interactive* specifies <[how the function should be called interactively]>

****** Example

(interactive "bBuffer to rename: \nsRename buffer %s to: ")

**** 1.1.5 The Substitution Model for Procedure Application
***** Applicative Order                                           :drill:
SCHEDULED: <2021-05-15 Sat>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       2efd00dd-9bb5-415b-a4ef-3735c38565d0
:DRILL_LAST_INTERVAL: 357.0975
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-05-23 Sat 12:14]
:END:

cs: <[Applicative Order]> is an *Evaluation Strategy* that <[evaluates the
arguments before applying the function]>

****** Tip

*A* plicative order *A* pplies the *A* rguments first, and expands the function
second.

***** Normal Order                                                :drill:
SCHEDULED: <2021-08-26 Thu>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       4143103f-0c1b-4132-8d2f-f855a53929bb
:DRILL_LAST_INTERVAL: 332.9208
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.143
:DRILL_EASE: 1.66
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-09-27 Sun 13:08]
:END:

cs: <[Normal Order]> is an *Evaluation Strategy* that <[fully expands the
expression before applying the functions]>

***** Lisp Uses Applicative Order                                 :drill:
SCHEDULED: <2021-10-13 Wed>
:PROPERTIES:
:ID:       D22C1F10-E13E-4F6F-BB73-5E8ABD340120
:DRILL_LAST_INTERVAL: 526.5456
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-05-04 Mon 15:01]
:END:

lisp: Lisp uses the <[Applicative Order]> Evalution Strategy

***** Why Lisp Uses Applicative Order                             :drill:
SCHEDULED: <2022-05-26 Thu>
:PROPERTIES:
:ID:       F9200285-F9BE-4E14-9D8D-6047899533F7
:DRILL_LAST_INTERVAL: 602.6282
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.857
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-09-30 Wed 13:43]
:END:

lisp: Why does *Lisp* use the *Applicative Order* Evalution Strategy?

****** Answer

Because it avoids evaluating the same expressions multiple times

**** 1.1.6 Conditional Expressions and Predicates
***** Predicate                                                   :drill:
SCHEDULED: <2022-01-16 Sun>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       4d4220fa-7ffa-4a72-a5ed-102c2d3a56d3
:DRILL_LAST_INTERVAL: 532.4198
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-08-02 Sun 08:31]
:END:

cs: A <[*Predicate*]> is an expression that returns <[a boolean]>

***** =if=                                                        :drill:
SCHEDULED: <2021-05-22 Sat>
:PROPERTIES:
:ID:       dcb0067d-62cf-4dcb-a440-83a65bf21a97
:DRILL_LAST_INTERVAL: 353.6424
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.668
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-06-02 Tue 14:53]
:END:

lisp: prototype: if: <[(if CONDITION THEN ELSE...)]>

***** =when=                                                      :drill:
SCHEDULED: <2022-09-20 Tue>
:PROPERTIES:
:ID:       506c5726-6435-4513-89af-570aaddd6092
:DRILL_LAST_INTERVAL: 642.3449
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-12-17 Thu 12:55]
:END:

lisp: prototype: when: <[(when CONDITION THEN...)]>

***** =unless=                                                    :drill:
SCHEDULED: <2021-07-04 Sun>
:PROPERTIES:
:ID:       af344d0a-3557-4410-961c-a3007b6356b9
:DRILL_LAST_INTERVAL: 400.5301
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-05-29 Fri 13:21]
:END:

lisp: prototype: unless: <[(unless CONDITION THEN...)]>

***** =cond= in elisp and scheme                                  :drill:
SCHEDULED: <2021-02-09 Tue>
:PROPERTIES:
:ID:       0a47d723-3330-462d-bc81-0b0ee63b1508
:DRILL_LAST_INTERVAL: 202.0893
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 16
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.313
:DRILL_EASE: 1.76
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-07-22 Wed 12:09]
:END:

elisp: prototype: cond:
<[(cond (CONDITION THEN...)...
        (t THEN))]>

scheme: prototype: cond:
<[(cond (CONDITION THEN...)...
        (else THEN))]>

***** Exercise 1.1

*Exercise 1.1:* Below is a sequence of expressions.  What is the
result printed by the interpreter in response to each expression?
Assume that the sequence is to be evaluated in the order in which
it is presented.

#+BEGIN_SRC
10

(+ 5 3 4)

(- 9 1)

(/ 6 2)

(+ (* 2 4) (- 4 6))

(define a 3)

(define b (+ a 1))

(+ a b (* a b))

(= a b)

(if (and (> b a) (< b (* a b)))
    b
    a)

(cond ((= a 4) 6)
    ((= b 4) (+ 6 7 a))
    (else 25))

(+ 2 (if (> b a) b a))

(* (cond ((> a b) a)
        ((< a b) b)
        (else -1))
    (+ a 1))
#+END_SRC

****** Solution

#+BEGIN_SRC scheme :results value :session
(define a 3)
(define b (+ a 1))
(and (equal? (+ 5 3 4) 12)
     (equal? (- 9 1) 8)
     (equal? (/ 6 2) 3)
     (equal? (+ (* 2 4) (- 4 6)) 6)
     (equal? (+ a b (* a b)) 19)
     (equal? (= a b) #f)
     (equal? (if (and (> b a) (< b (* a b)))
            b
            a)
        4)
     (equal? (cond ((= a 4) 6)
              ((= b 4) (+ 6 7 a))
              (else 25))
        16)
     (equal? (+ 2 (if (> b a) b a)) 6)
     (equal? (* (cond ((> a b) a)
                 ((< a b) b)
                 (else -1))
           (+ a 1))
        16))
#+END_SRC

#+RESULTS:
: #t

***** Exercise 1.2

*Exercise 1.2:* Translate the following expression into prefix
form.

#+BEGIN_SRC
5 + 4 + (2 - (3 - (6 + 4/5)))
-----------------------------
       3(6 - 2)(2 - 7)
#+END_SRC

****** Solution

#+BEGIN_SRC scheme :results value :session
(= (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
      (* 3 (- 6 2) (- 2 7)))
   -37/150)
#+END_SRC

#+RESULTS:
: #t

***** Exercise 1.3

*Exercise 1.3:* Define a procedure that takes three numbers as
arguments and returns the sum of the squares of the two larger
numbers.

****** Solution

#+BEGIN_SRC scheme :results value :session
(define (solution a b c)
  (cond ((and (>= a c) (>= b c)) (+ (* a a) (* b b)))
        ((and (>= b a) (>= c a)) (+ (* b b) (* c c)))
        ((and (>= a b) (>= c c)) (+ (* a a) (* c c)))))

(define (test)
  (= (solution 2 3 4) 25)
  (= (solution 3 4 2) 25)
  (= (solution 3 2 4) 25)
  (= (solution 2 2 2) 8))

(test)
#+END_SRC

#+RESULTS:
: #t

***** Exercise 1.4

*Exercise 1.4:* Observe that our model of evaluation allows for
combinations whose operators are compound expressions.  Use this
observation to describe the behavior of the following procedure:

#+BEGIN_SRC scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
#+END_SRC

****** Solution

The function =a-plus-abs-b= will return =a + b= if the b is strictly over 0,
otherwise it will return =a - b=.

***** Exercise 1.5

*Exercise 1.5:* Ben Bitdiddle has invented a test to determine
whether the interpreter he is faced with is using
applicative-order evaluation or normal-order evaluation.  He
defines the following two procedures:

#+BEGIN_SRC scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
#+END_SRC

Then he evaluates the expression

#+BEGIN_SRC scheme
(test 0 (p))
#+END_SRC

What behavior will Ben observe with an interpreter that uses
applicative-order evaluation?  What behavior will he observe with
an interpreter that uses normal-order evaluation?  Explain your
answer.  (Assume that the evaluation rule for the special form
`if' is the same whether the interpreter is using normal or
applicative order: The predicate expression is evaluated first,
and the result determines whether to evaluate the consequent or
the alternative expression.)

****** Solution

With an applicative order evaluation strategy it would unfold as follows:

#+BEGIN_SRC
(test 0 (p))

(p) is evaluated and since it's an infinite recursion the interpreter would hang
indefinitely.
#+END_SRC

With a normal order evaluation strategy it would unfold as follows:

#+BEGIN_SRC
(test 0 (p))

is expanded to:

(if (= 0 0)
    0
    (p))

which would return 0.
#+END_SRC

**** 1.1.7 Example: Square Roots by Newton's Method
***** Exercise 1.6

*Exercise 1.6:* Alyssa P. Hacker doesn't see why `if' needs to be
provided as a special form.  "Why can't I just define it as an
ordinary procedure in terms of `cond'?" she asks.  Alyssa's friend
Eva Lu Ator claims this can indeed be done, and she defines a new
version of `if':

#+BEGIN_SRC scheme
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
#+END_SRC

Eva demonstrates the program for Alyssa:

#+BEGIN_SRC
(new-if (= 2 3) 0 5)
5

(new-if (= 1 1) 0 5)
0
#+END_SRC

Delighted, Alyssa uses `new-if' to rewrite the square-root program:

#+BEGIN_SRC scheme
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
#+END_SRC

What happens when Alyssa attempts to use this to compute square
roots?  Explain.

****** Solution

Since =new-if= isn't a special form, all of its operand would be evaluated
before executing its code (according to the applicative order evaluation
strategy) which means that this would introduce an infinite recursion at the
time of evaluation.

***** Exercise 1.7

*Exercise 1.7:* The `good-enough?' test used in computing square
roots will not be very effective for finding the square roots of
very small numbers.  Also, in real computers, arithmetic operations
are almost always performed with limited precision.  This makes
our test inadequate for very large numbers.  Explain these
statements, with examples showing how the test fails for small and
large numbers.  An alternative strategy for implementing
`good-enough?' is to watch how `guess' changes from one iteration
to the next and to stop when the change is a very small fraction
of the guess.  Design a square-root procedure that uses this kind
of end test.  Does this work better for small and large numbers?

****** Solution

Testing that the difference between the square of the guess and the radicand is
less than 0.001 shows that the intended result be good "up to" 2 decimal places
for radicands above 1.

However for the radicands that are close to 0.001 or less wouldn't benefit from
a similar precision. If the radicand was 1 with the original tolerance, a
similar tolerance number would be 0.000001 with 0.001 as a radicand.

Similarly, for very large numbers the tolerance would be too small and the guess
would never be good enough because of the lack of the necessary precision in the
machine operations. This would result in an infinite execution.

Example with a small number:

#+BEGIN_SRC scheme :results output :session "1.7"
(define (average x y)
  (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(define (bad-sqrt x)
  (sqrt-iter 1.0 x))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC scheme :results output :session "1.7"
(define radicand 0.0009)
(display (bad-sqrt radicand))
(newline)
(display (sqrt radicand))
#+END_SRC

#+RESULTS:
: .04030062264654547
: .03

Here is a version of the algorithm which checks the differences between the
guesses. This is done by checking that the difference between two guesses is
smaller than one thousandth of guess:

#+BEGIN_SRC scheme :results value :session
(define (average x y)
  (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (good-enough? guess x)
  (< (abs (- guess (improve guess x)))
  (* guess .001)))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(define (better-sqrt x)
  (sqrt-iter 1.0 x))

(better-sqrt 0.0009)
#+END_SRC

#+RESULTS:
: 0.03002766742182557

***** Exercise 1.8

*Exercise 1.8:* Newton's method for cube roots is based on the
fact that if y is an approximation to the cube root of x, then a
better approximation is given by the value

#+BEGIN_SRC
x/y^2 + 2y
----------
    3
#+END_SRC

Use this formula to implement a cube-root procedure analogous to
the square-root procedure.  (In section *Note 1-3-4:: we will see
how to implement Newton's method in general as an abstraction of
these square-root and cube-root procedures.)

****** Solution

#+BEGIN_SRC scheme :results value :session
(define (improve guess x)
  (/ (+ (/ x (square guess)) (* 2 guess))
     3))

(define (good-enough? guess x)
  (< (abs (- guess (improve guess x)))
  (* guess .001)))

(define (cube-root-iter guess x)
  (if (good-enough? guess x)
      guess
      (cube-root-iter (improve guess x)
                 x)))

(define (cube-root x)
  (cube-root-iter 1.0 x))

(cube-root 27)
#+END_SRC

#+RESULTS:
: 3.001274406506175

**** 1.1.8 Procedures as Black-Box Abstractions
*** 1.2 Procedures and the Processes They Generate
**** 1.2.1 Linear Recursion and Iteration
***** Procedure != Process                                        :drill:
SCHEDULED: <2021-12-09 Thu>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       ff195e38-d812-4dcb-abcf-78c7a1f6eeb1
:DRILL_LAST_INTERVAL: 499.9922
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-07-27 Mon 11:30]
:END:

cs: A recursive <[procedure]> can have an iterative <[process]>

***** How to Design Recursive Algorithms                          :drill:
SCHEDULED: <2021-02-23 Tue>
:PROPERTIES:
:ID:       3013d589-5a12-4d44-a14b-772858c48f73
:DRILL_LAST_INTERVAL: 53.247
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.429
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-01 Fri 15:40]
:END:

cs: How to design recursive algorithms:
<[
- Assume the desired procedure exists BUT only solves a smaller version of the problem
- Use that to come up with the desired solution
- Solve the smallest problem manually (AKA stopping condition)

Example, for the factorial:
- Assume fact(n - 1) exists
- Guess that fact(n) is n * fact(n - 1)
- Stop the recursive with fact(1) = 1

Result:
#+BEGIN_SRC scheme
(define (fact n)
 (if (= n 1)                ; test for base case
     1                      ; base case
     (* n (fact (- n 1))))) ; recursive case
#+END_SRC
]>

***** Exercise 1.9

*Exercise 1.9:* Each of the following two procedures defines a
method for adding two positive integers in terms of the procedures
`inc', which increments its argument by 1, and `dec', which
decrements its argument by 1.

#+BEGIN_SRC scheme
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
#+END_SRC

Using the substitution model, illustrate the process generated by
each procedure in evaluating `(+ 4 5)'.  Are these processes
iterative or recursive?

****** Solution

First procedure:

#+BEGIN_SRC
(+ 4 5)
(inc (+ (dec 4) 5))
(inc (+ 3 5))
(inc (inc (+ (dec 3) 5)))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ (dec 2) 5))))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ (dec 1) 5)))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
#+END_SRC

Second procedure:

#+BEGIN_SRC
(+ 4 5)
(+ (dec 4) (inc 5))
(+ 3 6)
(+ (dec 3) (inc 6))
(+ 2 7)
(+ (dec 2) (inc 7))
(+ 1 8)
(+ (dec 1) (inc 8))
(+ 0 9)
9
#+END_SRC

The first one is recursive. The second one is iterative.

***** Exercise 1.10

*Exercise 1.10:* The following procedure computes a mathematical
function called Ackermann's function.

#+BEGIN_SRC scheme
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
#+END_SRC

What are the values of the following expressions?

#+BEGIN_SRC scheme
(A 1 10)

(A 2 4)

(A 3 3)
#+END_SRC

Consider the following procedures, where `A' is the procedure
defined above:

#+BEGIN_SRC scheme
(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))
#+END_SRC

Give concise mathematical definitions for the functions computed
by the procedures `f', `g', and `h' for positive integer values of
n.  For example, `(k n)' computes 5n^2.

****** Solution

#+BEGIN_SRC scheme :results output
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

(display (A 1 10))
(newline)
(display (A 2 4))
(newline)
(display (A 3 3))
(newline)
#+END_SRC

#+RESULTS:
: 1024
: 65536
: 65536

=f(n)= computes =2*n=:
#+BEGIN_SRC
(A 0 n)
(* 2 n)
#+END_SRC

=g(n)= computes =2^n=:
#+BEGIN_SRC
(g 1)
(A 1 1)
2

(g n)
(A 1 n)
(A (- 1 1) (A 1 (- n 1))))
(A 0 (A 1 (- n 1))))
(* 2 (A 1 (- n 1))) ;; This is (* 2 (g (- n 1)))
#+END_SRC

h(n) computes =2^2^2...(n-1 exponentations, eg. h(2) -> 2^2)=:
#+BEGIN_SRC
(h 1)
(A 2 1)
2

(h n)
(A 2 n)
(A 1 (A 2 (- n 1))) ;; This is (g (h (- n 1))) -> 2^h(n-1) -> 2^2^h(n-2)
#+END_SRC

**** 1.2.2 Tree Recursion
***** Linear Recursion != Tree Recursion                          :drill:
SCHEDULED: <2021-03-16 Tue>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       68c19c55-93ca-4e7f-b07b-f73f321eb3c6
:DRILL_LAST_INTERVAL: 293.8681
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.04
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-05-26 Tue 15:21]
:END:

cs: <[Linear]> Recursion is different than <[Tree]> Recursion

***** Exercise 1.11

*Exercise 1.11:* A function f is defined by the rule that f(n) = n
if n<3 and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n>= 3.
Write a procedure that computes f by means of a recursive process.
Write a procedure that computes f by means of an iterative
process.

****** Solution

#+BEGIN_SRC scheme :results value :session
(define (f-recursive n)
  (cond ((< n 3) n)
        ((>= n 3) (+ (f-recursive (- n 1))
                     (* 2 (f-recursive (- n 2)))
                     (* 3 (f-recursive (- n 3)))))))

(define (f-iterative n)
  (cond ((< n 3) n)
        ((>= n 3) (f n 3 2 1 0))))

(define (f n current-n n-1 n-2 n-3)
  (if (= n current-n)
      (+ n-1
         (* 2 n-2)
         (* 3 n-3))
      (f n
         (+ current-n 1)
         (+ n-1
            (* 2 n-2)
            (* 3 n-3))
         n-1
         n-2)))

(and (= (f-recursive 6) (f-iterative 6))
     (= (f-recursive 6) 59))
#+END_SRC

#+RESULTS:
: #t

***** Exercise 1.12

*Exercise 1.12:* The following pattern of numbers is called "Pascal's
triangle".

#+BEGIN_SRC
        1
      1   1
    1   2   1
  1   3   3   1
1   4   6   4   1
#+END_SRC

The numbers at the edge of the triangle are all 1, and each number
inside the triangle is the sum of the two numbers above it.(4)
Write a procedure that computes elements of Pascal's triangle by
means of a recursive process.

****** Solution

#+BEGIN_SRC scheme :results value :session
(define (pascal-triangle line column)
  (if (or (= column 1) (= column line) (= line 1))
      1
      (+ (pascal-triangle (- line 1) (- column 1))
         (pascal-triangle (- line 1) column))))

(and (= (pascal-triangle 1 1) 1)
     (= (pascal-triangle 2 1) 1)
     (= (pascal-triangle 2 2) 1)
     (= (pascal-triangle 3 1) 1)
     (= (pascal-triangle 3 2) 2)
     (= (pascal-triangle 3 3) 1)
     (= (pascal-triangle 5 3) 6))
#+END_SRC

#+RESULTS:
: #t

***** Exercise 1.13

*Exercise 1.13:* Prove that _Fib_(n) is the closest integer to
[phi]^n/[sqrt](5), where [phi] = (1 + [sqrt](5))/2.  Hint: Let
[illegiblesymbol] = (1 - [sqrt](5))/2.  Use induction and the
definition of the Fibonacci numbers (see section *Note 1-2-2::) to
prove that _Fib_(n) = ([phi]^n - [illegiblesymbol]^n)/[sqrt](5).

****** TODO Solution
**** 1.2.3 Orders of Growth
***** Exercise 1.14

*Exercise 1.14:* Draw the tree illustrating the process generated
by the `count-change' procedure of section *Note 1-2-2:: in making
change for 11 cents.  What are the orders of growth of the space
and number of steps used by this process as the amount to be
changed increases?

****** TODO Solution

Here is a script to generate a call graph with =graphviz=:

#+BEGIN_SRC scheme :results output :session
(define (count-change amount)
  (cc amount 5))

(define (cc depth amount kinds-of-coins)
  (map display
       (list "\"[" depth "] (cc " amount " " kinds-of-coins ")\" [color="
             (cond ((= kinds-of-coins 0) "gray80")
                   ((= kinds-of-coins 1) "lightblue")
                   (else "gray95"))
             "];\n"))

  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else
         (map display
              (list
               "\"[" depth "] (cc " amount " " kinds-of-coins ")\" -> \"[" (+ depth 1) "] (cc " amount " " (- kinds-of-coins 1) ")\";\n"
               "\"[" depth "] (cc " amount " " kinds-of-coins ")\" -> \"[" (+ depth 1) "] (cc " (- amount (first-denomination kinds-of-coins)) " " kinds-of-coins ")\";\n"))
         (+ (cc (+ depth 1) amount
                     (- kinds-of-coins 1))
                 (cc (+ depth 1) (- amount
                                    (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(display "digraph G {
node [color = gray95,style=filled];
graph [ranksep=0.3,size=7];
node [color = gray95,style=filled,fontsize=9,shape=box, margin=.08, width=0, height=0 ];
edge [penwidth=.1, arrowsize=0.5];\n")
(cc 0 11 5)
(display "}")
#+END_SRC

***** Exercise 1.15

*Exercise 1.15:* The sine of an angle (specified in radians) can
be computed by making use of the approximation `sin' xapprox x if
x is sufficiently small, and the trigonometric identity

                    x             x
    sin x = 3 sin --- - 4 sin^3 ---
                    3             3

to reduce the size of the argument of `sin'.  (For purposes of this
exercise an angle is considered "sufficiently small" if its
magnitude is not greater than 0.1 radians.) These ideas are
incorporated in the following procedures:

#+BEGIN_SRC scheme
(define (cube x) (* x x x))

(define (p x) (- (* 3 x) (* 4 (cube x))))

(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
#+END_SRC

a. How many times is the procedure `p' applied when `(sine
  12.15)' is evaluated?

b. What is the order of growth in space and number of steps (as
  a function of a) used by the process generated by the `sine'
  procedure when `(sine a)' is evaluated?

****** Solution

p will be recursively called until the angle is strictly inferior to 0.1, so we have:

#+BEGIN_SRC
12.15/3.0^n < 0.1
12.15 < 0.1*3.0^n
12.15/0.1 < 3.0^n
log(3.0, 121.5) < log(3.0, 3.0^n)
4.369 < n, n ∈ ℕ
n = 5
#+END_SRC

Let's verify this:

#+BEGIN_SRC scheme :results output :session
(define (cube x) (* x x x))

(define (p x)
  (display "p is called\n")
  (- (* 3 x) (* 4 (cube x))))

(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
    (p (sine (/ angle 3.0)))))

(sine 12.15)
#+END_SRC

#+RESULTS:
: p is called
: p is called
: p is called
: p is called
: p is called

The order of growth in space should be equal to the number of times p or sine are called
recursively, which should be equal to =log(3.0, a/0.1)= so in O() notation =O(log(a))=.

The order of growth in space should be equal to the number of times p and sine are called,
which should be equal to =2*log(3.0, a/0.1)= so in O() notation =O(log(a))=.

**** 1.2.4 Exponentiation
***** Exercise 1.16

*Exercise 1.16:* Design a procedure that evolves an iterative
exponentiation process that uses successive squaring and uses a
logarithmic number of steps, as does `fast-expt'.  (Hint: Using the
observation that (b^(n/2))^2 = (b^2)^(n/2), keep, along with the
exponent n and the base b, an additional state variable a, and
define the state transformation in such a way that the product a
b^n is unchanged from state to state.  At the beginning of the
process a is taken to be 1, and the answer is given by the value
of a at the end of the process.  In general, the technique of
defining an "invariant quantity" that remains unchanged from state
to state is a powerful way to think about the design of iterative
algorithms.)

****** Solution

#+BEGIN_SRC scheme :results value :session
(define (even? n)
  (= (remainder n 2) 0))

;; Iterative algorithm with iterative process
(define (fast-expt-iterative b n)
  (let ((result 1))
    (do ((n n (cond ((even? n) (/ n 2))
                    (else (- n 1)))))
        ((= n 0) result)
      (cond ((even? n) (set! b (square b)))
            (else (set! result (* result b)))))))


;; Iterative algorithm with tail-recursive process
(define (fast-expt-iterative2 b n)
  (define (expt a b n)
    (cond ((= 0 n) a)
          ((even? n) (expt a (square b) (/ n 2)))
          (else (expt (* a b) b (- n 1)))))
  (expt 1 b n))

(and (= (fast-expt-iterative 3 0) 1)
     (= (fast-expt-iterative 5 1) 5)
     (= (fast-expt-iterative 7 2) 49)
     (= (fast-expt-iterative 3 3) 27)
     (= (fast-expt-iterative 3 4) 81)
     (= (fast-expt-iterative 2 5) 32)
     (= (fast-expt-iterative 2 6) 64)
     (= (fast-expt-iterative 2 7) 128)
     (= (fast-expt-iterative2 3 0) 1)
     (= (fast-expt-iterative2 5 1) 5)
     (= (fast-expt-iterative2 7 2) 49)
     (= (fast-expt-iterative2 3 3) 27)
     (= (fast-expt-iterative2 3 4) 81)
     (= (fast-expt-iterative2 2 5) 32)
     (= (fast-expt-iterative2 2 6) 64)
     (= (fast-expt-iterative2 2 7) 128))
#+END_SRC

#+RESULTS:
: #t

***** Exercise 1.17

*Exercise 1.17:* The exponentiation algorithms in this section are
based on performing exponentiation by means of repeated
multiplication.  In a similar way, one can perform integer
multiplication by means of repeated addition.  The following
multiplication procedure (in which it is assumed that our language
can only add, not multiply) is analogous to the `expt' procedure:

#+BEGIN_SRC scheme
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
#+END_SRC

This algorithm takes a number of steps that is linear in `b'.  Now
suppose we include, together with addition, operations `double',
which doubles an integer, and `halve', which divides an (even)
integer by 2.  Using these, design a multiplication procedure
analogous to `fast-expt' that uses a logarithmic number of steps.

****** Solution

#+BEGIN_SRC scheme :results value :session
(define (even? n)
  (= (remainder n 2) 0))

(define (double num)
  (+ num num))

(define (halve num)
  (/ num 2))

(define (* a b)
  (if (= b 0)
      0
      (cond ((even? b) (* (double a) (halve b)))
            (else (+ a (* a (- b 1)))))))

(and (= (* 0 3) 0)
     (= (* 1 1) 1)
     (= (* 1 2) 2)
     (= (* 1 3) 3)
     (= (* 2 2) 4)
     (= (* 2 3) 6)
     (= (* 3 2) 6)
     (= (* 3 3) 9)
     (= (* 4 2) 8)
     (= (* 4 3) 12))
#+END_SRC

#+RESULTS:
: #t

***** Exercise 1.18

*Exercise 1.18:* Using the results of *Note Exercise 1-16:: and
*Note Exercise 1-17::, devise a procedure that generates an
iterative process for multiplying two integers in terms of adding,
doubling, and halving and uses a logarithmic number of steps.(4)

****** Solution

#+BEGIN_SRC scheme :results value :session
(define (even? n)
  (= (remainder n 2) 0))

(define (double num)
  (+ num num))

(define (halve num)
  (/ num 2))

(define (* a b)
  (define (mult product a b)
    (if (= b 0)
        product
        (cond ((even? b) (mult product (double a) (halve b)))
              (else (mult (+ product a) a (- b 1))))))
  (mult 0 a b))

(and (= (* 0 3) 0)
     (= (* 1 1) 1)
     (= (* 1 2) 2)
     (= (* 1 3) 3)
     (= (* 2 2) 4)
     (= (* 2 3) 6)
     (= (* 3 2) 6)
     (= (* 3 3) 9)
     (= (* 4 2) 8)
     (= (* 4 3) 12))
#+END_SRC

#+RESULTS:
: #t

***** Exercise 1.19

*Exercise 1.19:* There is a clever algorithm for computing the
Fibonacci numbers in a logarithmic number of steps.  Recall the
transformation of the state variables a and b in the `fib-iter'
process of section *Note 1-2-2::: a <- a + b and b <- a.  Call
this transformation T, and observe that applying T over and over
again n times, starting with 1 and 0, produces the pair _Fib_(n +
1) and _Fib_(n).  In other words, the Fibonacci numbers are
produced by applying T^n, the nth power of the transformation T,
starting with the pair (1,0).  Now consider T to be the special
case of p = 0 and q = 1 in a family of transformations T_(pq),
where T_(pq) transforms the pair (a,b) according to a <- bq + aq +
ap and b <- bp + aq.  Show that if we apply such a transformation
T_(pq) twice, the effect is the same as using a single
transformation T_(p'q') of the same form, and compute p' and q' in
terms of p and q.  This gives us an explicit way to square these
transformations, and thus we can compute T^n using successive
squaring, as in the `fast-expt' procedure.  Put this all together
to complete the following procedure, which runs in a logarithmic
number of steps:(5)

#+BEGIN_SRC scheme
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   <??>      ; compute p'
                   <??>      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
#+END_SRC

****** Solution

So we have:
#+BEGIN_SRC
a = bq + aq + ap
b = bp + aq
#+END_SRC

Let's apply a second time to get a' and b':
#+BEGIN_SRC
a' = (bq + aq)q + (bq + aq + ap)q + (bq + aq + ap)p
   = bpq + aq^2 + bq^2 + aq^2 + apq + bpq + apq + ap^2

b' = (bp + aq)p + (bq + aq + ap)q
   = bp^2 + apq + bq^2 + aq^2 + apq
#+END_SRC

The factorisation isn't obvious for a' but it is for b':
#+BEGIN_SRC
b' = b(p^2 + q^2) + a(2pq + q^2)
#+END_SRC

From there we can now work out a':
#+BEGIN_SRC
a' = b(2pq + q^2) + a(2pq + q^2) + a(p^2 + q^2)
#+END_SRC

So we have found p' and q' which are:
#+BEGIN_SRC
p' = p^2 + q^2
q' = 2pq + q^2
#+END_SRC

Let's use those in the provided source code:
#+BEGIN_SRC scheme :results value :session
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* p p) (* q q))
                   (+ (* 2 p q) (* q q))
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))

(and (= (fib 0) 0)
     (= (fib 1) 1)
     (= (fib 2) 1)
     (= (fib 3) 2)
     (= (fib 4) 3)
     (= (fib 5) 5)
     (= (fib 6) 8)
     (= (fib 7) 13)
     (= (fib 25) 75025))
#+END_SRC

#+RESULTS:
: #t

***** Exercise 1.20

*Exercise 1.20:* The process that a procedure generates is of
course dependent on the rules used by the interpreter.  As an
example, consider the iterative `gcd' procedure given above.
Suppose we were to interpret this procedure using normal-order
evaluation, as discussed in section *Note 1-1-5::.  (The
normal-order-evaluation rule for `if' is described in *Note
Exercise 1-5::.)  Using the substitution method (for normal
order), illustrate the process generated in evaluating `(gcd 206
40)' and indicate the `remainder' operations that are actually
performed.  How many `remainder' operations are actually performed
in the normal-order evaluation of `(gcd 206 40)'?  In the
applicative-order evaluation?

****** Solution

#+BEGIN_SRC scheme
(gcd 206 40)
(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))

(gcd 40 (remainder 206 40))
(if (= (remainder 206 40) 0) ... (= 6 0)
    40
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))
1 call

(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
(if (= (remainder 40 (remainder 206 40)) 0) ... (= 4 0)
    (remainder 206 40)
    (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
2 calls

(gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
(if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0) ... (= 2 0)
    (remainder 40 (remainder 206 40))
    (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))
4 calls

(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
(if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0) ... (= 0 0)
    (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ... 2
    (gcd (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))
7 + 4 calls
#+END_SRC

There is 18 calls to `remainder` in total.

***** Exercise 1.21

*Exercise 1.21:* Use the `smallest-divisor' procedure to find the
smallest divisor of each of the following numbers: 199, 1999,
19999.

****** Solution

#+BEGIN_SRC scheme :results output :session
(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))

(map display (list (smallest-divisor 199) "\n"
                   (smallest-divisor 1999) "\n"
                   (smallest-divisor 19999) "\n"))
#+END_SRC

#+RESULTS:
: 199
: 1999
: 7

***** Exercise 1.22

*Exercise 1.22:* Most Lisp implementations include a primitive
called `runtime' that returns an integer that specifies the amount
of time the system has been running (measured, for example, in
microseconds).  The following `timed-prime-test' procedure, when
called with an integer n, prints n and checks to see if n is
prime.  If n is prime, the procedure prints three asterisks
followed by the amount of time used in performing the test.

#+BEGIN_SRC scheme
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
#+END_SRC

Using this procedure, write a procedure `search-for-primes' that
checks the primality of consecutive odd integers in a specified
range.  Use your procedure to find the three smallest primes
larger than 1000; larger than 10,000; larger than 100,000; larger
than 1,000,000.  Note the time needed to test each prime.  Since
the testing algorithm has order of growth of [theta](_[sqrt]_(n)),
you should expect that testing for primes around 10,000 should
take about _[sqrt]_(10) times as long as testing for primes around
1000.  Do your timing data bear this out?  How well do the data
for 100,000 and 1,000,000 support the _[sqrt]_(n) prediction?  Is
your result compatible with the notion that programs on your
machine run in time proportional to the number of steps required
for the computation?

****** Solution

I have used larger values in order to be able to see the increase on my computer:

#+BEGIN_SRC scheme :results output :session
(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (timed-prime-test n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (define is-prime (prime? n))
  (if is-prime
      (report-prime n (- (runtime) start-time)))
  is-prime)

(define (report-prime prime elapsed-time)
  (display prime)
  (display " *** ")
  (display elapsed-time)
  (newline))

(define (search-for-primes range-start range-end)
  (if (<= range-start range-end)
      (cond ((even? range-start) (search-for-primes (+ range-start 1) range-end))
            (else (timed-prime-test range-start) (search-for-primes (+ range-start 2) range-end)))))

(search-for-primes 100000000000 100000000060)
(newline)
(search-for-primes 1000000000000 1000000000090)
(newline)
(search-for-primes 10000000000000 10000000000100)
#+END_SRC

#+RESULTS:
#+begin_example
100000000003 *** .21999999999999997
100000000019 *** .22999999999999998
100000000057 *** .19999999999999996

1000000000039 *** .6199999999999999
1000000000061 *** .6299999999999999
1000000000063 *** .6699999999999999

10000000000037 *** 1.98
10000000000051 *** 2.089999999999999
10000000000099 *** 1.9800000000000004
#+end_example

It indeed increases by roughly sqrt(10):
- 0.2 * sqrt(10) = 0.63
- 0.63 * sqrt(10) = 1.99

***** Exercise 1.23

*Exercise 1.23:* The `smallest-divisor' procedure shown at the
start of this section does lots of needless testing: After it
checks to see if the number is divisible by 2 there is no point in
checking to see if it is divisible by any larger even numbers.
This suggests that the values used for `test-divisor' should not
be 2, 3, 4, 5, 6, ..., but rather 2, 3, 5, 7, 9, ....  To
implement this change, define a procedure `next' that returns 3 if
its input is equal to 2 and otherwise returns its input plus 2.
Modify the `smallest-divisor' procedure to use `(next
test-divisor)' instead of `(+ test-divisor 1)'.  With
`timed-prime-test' incorporating this modified version of
`smallest-divisor', run the test for each of the 12 primes found in
*Note Exercise 1-22::.  Since this modification halves the number
of test steps, you should expect it to run about twice as fast.
Is this expectation confirmed?  If not, what is the observed ratio
of the speeds of the two algorithms, and how do you explain the
fact that it is different from 2?

****** Solution

#+BEGIN_SRC scheme :results output :session
(define (next n)
  (if (= n 2)
      3
      (+ n 2)))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))

(define (divides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (timed-prime-test n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (define is-prime (prime? n))
  (if is-prime
      (report-prime n (- (runtime) start-time)))
  is-prime)

(define (report-prime prime elapsed-time)
  (display prime)
  (display " *** ")
  (display elapsed-time)
  (newline))

(define (search-for-primes range-start range-end)
  (if (<= range-start range-end)
      (cond ((even? range-start) (search-for-primes (+ range-start 1) range-end))
            (else (timed-prime-test range-start) (search-for-primes (+ range-start 2) range-end)))))

(search-for-primes 100000000000 100000000060)
(newline)
(search-for-primes 1000000000000 1000000000090)
(newline)
(search-for-primes 10000000000000 10000000000100)
#+END_SRC

#+RESULTS:
#+begin_example
100000000003 *** .129999999999999
100000000019 *** .120000000000001
100000000057 *** .120000000000001

1000000000039 *** .39000000000000057
1000000000061 *** .379999999999999
1000000000063 *** .39000000000000057

10000000000037 *** 1.259999999999998
10000000000051 *** 1.2299999999999969
10000000000099 *** 1.2199999999999989
#+end_example

We see a speedup of about 1.6. It's most likely not 2 because we didn't exactly halve the number of
operations. While there is twice less divisions, there is also another =if= betwen each operations.
Let's manually check for 2 and then increase 2 by 2 from 3.

#+BEGIN_SRC scheme :results output :session
(define (smallest-divisor n)
  (if (divides? 2 n)
      2
      (find-divisor n 3)))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 2)))))

(search-for-primes 100000000000 100000000060)
(newline)
(search-for-primes 1000000000000 1000000000090)
(newline)
(search-for-primes 10000000000000 10000000000100)
#+END_SRC

#+RESULTS:
#+begin_example
100000000003 *** .14999999999999858
100000000019 *** .10999999999999943
100000000057 *** .09999999999999787

1000000000039 *** .3099999999999987
1000000000061 *** .3100000000000023
1000000000063 *** .3099999999999987

10000000000037 *** 1.
10000000000051 *** 1.
10000000000099 *** .990000000000002
#+end_example

We now get our factor of 2 speedup.

***** Exercise 1.24

*Exercise 1.24:* Modify the `timed-prime-test' procedure of *Note
Exercise 1-22:: to use `fast-prime?' (the Fermat method), and test
each of the 12 primes you found in that exercise.  Since the
Fermat test has [theta](`log' n) growth, how would you expect the
time to test primes near 1,000,000 to compare with the time needed
to test primes near 1000?  Do your data bear this out?  Can you
explain any discrepancy you find?

****** Solution

I expect the time needed to increase by only a small amount.

#+BEGIN_SRC scheme :results output :session
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

(define (timed-prime-test n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (define is-prime (fast-prime? n 10000))
  (if is-prime
      (report-prime n (- (runtime) start-time)))
  is-prime)

(define (report-prime prime elapsed-time)
  (display prime)
  (display " *** ")
  (display elapsed-time)
  (newline))

(define (search-for-primes range-start range-end)
  (if (<= range-start range-end)
      (cond ((even? range-start) (search-for-primes (+ range-start 1) range-end))
            (else (timed-prime-test range-start) (search-for-primes (+ range-start 2) range-end)))))

(search-for-primes 100000000000000000000000000 100000000000000000000000200)
(newline)
(search-for-primes 100000000000000000000000000000 100000000000000000000000000480)
#+END_SRC

#+RESULTS:
: 100000000000000000000000067 *** 1.25
: 100000000000000000000000123 *** 1.1999999999999957
: 100000000000000000000000127 *** 1.220000000000006
:
: 100000000000000000000000000319 *** 1.4500000000000028
: 100000000000000000000000000379 *** 1.4200000000000017
: 100000000000000000000000000459 *** 1.3900000000000006

***** Exercise 1.25

*Exercise 1.25:* Alyssa P. Hacker complains that we went to a lot
of extra work in writing `expmod'.  After all, she says, since we
already know how to compute exponentials, we could have simply
written

#+BEGIN_SRC scheme
(define (expmod base exp m)
  (remainder (fast-expt base exp) m))
#+END_SRC

Is she correct?  Would this procedure serve as well for our fast
prime tester?  Explain.

****** Solution

Instead of calling =remainder= multiple times, on smaller numbers, her function calls =remainder=
once on one large number. This will possibly be slower, because the scheme runtime may have to
resort to the use of bignums.

***** Exercise 1.26

*Exercise 1.26:* Louis Reasoner is having great difficulty doing
*Note Exercise 1-24::.  His `fast-prime?' test seems to run more
slowly than his `prime?' test.  Louis calls his friend Eva Lu Ator
over to help.  When they examine Louis's code, they find that he
has rewritten the `expmod' procedure to use an explicit
multiplication, rather than calling `square':

#+BEGIN_SRC scheme
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))
#+END_SRC

"I don't see what difference that could make," says Louis.  "I
do."  says Eva.  "By writing the procedure like that, you have
transformed the [theta](`log' n) process into a [theta](n)
process."  Explain.

****** Solution

Louis has effectively removed the optimization from this algorithm by forcing the procedure to
compute the same costly thing (=(expmod base (/ exp 2) m)=) twice.

***** Exercise 1.27

*Exercise 1.27:* Demonstrate that the Carmichael numbers listed in
*Note Footnote 1-47:: really do fool the Fermat test.  That is,
write a procedure that takes an integer n and tests whether a^n is
congruent to a modulo n for every a<n, and try your procedure on
the given Carmichael numbers.

****** Solution

#+BEGIN_SRC scheme :results value :session
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))

(define (fermat-test-all n)
  (define (try-it a)
    (= (expmod a n n) a))
  (define (test n a all-equal)
    (cond ((= a 0) all-equal)
          (else (test n (- a 1) (and (try-it a) all-equal)))))
  (test n (- n 1) #t))

(and (fermat-test-all 561)
     (fermat-test-all 1729)
     (fermat-test-all 2465)
     (fermat-test-all 2821)
     (fermat-test-all 6601))
#+END_SRC

#+RESULTS:
: #t

***** Exercise 1.28

*Exercise 1.28:* One variant of the Fermat test that cannot be
fooled is called the "Miller-Rabin test" (Miller 1976; Rabin
1980).  This starts from an alternate form of Fermat's Little
Theorem, which states that if n is a prime number and a is any
positive integer less than n, then a raised to the (n - 1)st power
is congruent to 1 modulo n.  To test the primality of a number n
by the Miller-Rabin test, we pick a random number a<n and raise a
to the (n - 1)st power modulo n using the `expmod' procedure.
However, whenever we perform the squaring step in `expmod', we
check to see if we have discovered a "nontrivial square root of 1
modulo n," that is, a number not equal to 1 or n - 1 whose square
is equal to 1 modulo n.  It is possible to prove that if such a
nontrivial square root of 1 exists, then n is not prime.  It is
also possible to prove that if n is an odd number that is not
prime, then, for at least half the numbers a<n, computing a^(n-1)
in this way will reveal a nontrivial square root of 1 modulo n.
(This is why the Miller-Rabin test cannot be fooled.)  Modify the
`expmod' procedure to signal if it discovers a nontrivial square
root of 1, and use this to implement the Miller-Rabin test with a
procedure analogous to `fermat-test'.  Check your procedure by
testing various known primes and non-primes.  Hint: One convenient
way to make `expmod' signal is to have it return 0.

****** Solution

#+BEGIN_SRC scheme :results output :session
(define (expmod base exp m)
  (define root 0)
  (define mod 0)
  (cond ((= exp 0) 1)
        ((even? exp)
         (set! root (expmod base (/ exp 2) m))
         (set! mod (remainder (square root) m))
         (if (and (= mod 1) (not (or (= root 1)
                                     (= root (- m 1)))))
             0
             mod)
         )
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))

(define (miller-rabin-test n)
  (define (try-it a)
    (cond ((> a (+ (/ n 2) 1)) #t)
          (else (and (= (expmod a (- n 1) n) 1) (try-it (+ a 1))))))
  (try-it 1))

(define (test n)
  (map display (list "(miller-rabin-test " n ") -> " (miller-rabin-test n) "\n")))

(map test (list 11 13 17 19 23 29 31 37))
(map test (list 4 6 8 9 10 12 14 15 16))
(map test (list 561 1729 2465 2821 6601))
#+END_SRC

#+RESULTS:
#+begin_example
(miller-rabin-test 11) -> #t
(miller-rabin-test 13) -> #t
(miller-rabin-test 17) -> #t
(miller-rabin-test 19) -> #t
(miller-rabin-test 23) -> #t
(miller-rabin-test 29) -> #t
(miller-rabin-test 31) -> #t
(miller-rabin-test 37) -> #t
(miller-rabin-test 4) -> #f
(miller-rabin-test 6) -> #f
(miller-rabin-test 8) -> #f
(miller-rabin-test 9) -> #f
(miller-rabin-test 10) -> #f
(miller-rabin-test 12) -> #f
(miller-rabin-test 14) -> #f
(miller-rabin-test 15) -> #f
(miller-rabin-test 16) -> #f
(miller-rabin-test 561) -> #f
(miller-rabin-test 1729) -> #f
(miller-rabin-test 2465) -> #f
(miller-rabin-test 2821) -> #f
(miller-rabin-test 6601) -> #f
#+end_example

*** 1.3 Formulating Abstractions with Higher-Order Procedures
**** Higher-Order Procedures                                       :drill:
SCHEDULED: <2021-02-02 Tue>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       a24f5a64-e8f8-45e4-a25c-7e19054919dd
:DRILL_LAST_INTERVAL: 54.9785
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-12-09 Wed 14:15]
:END:

cs: Procedures that <[take procedures as arguments or return procedures]> are called <[Higher-Order
Procedures]>

**** 1.3.1 Procedures as Arguments
***** Exercise 1.29

*Exercise 1.29:* Simpson's Rule is a more accurate method of
numerical integration than the method illustrated above.  Using
Simpson's Rule, the integral of a function f between a and b is
approximated as

#+BEGIN_SRC
h
- (y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + ... + 2y_(n-2) + 4y_(n-1) + y_n)
3
#+END_SRC

where h = (b - a)/n, for some even integer n, and y_k = f(a + kh).
(Increasing n increases the accuracy of the approximation.)
Define a procedure that takes as arguments f, a, b, and n and
returns the value of the integral, computed using Simpson's Rule.
Use your procedure to integrate `cube' between 0 and 1 (with n =
100 and n = 1000), and compare the results to those of the
`integral' procedure shown above.

****** Solution

#+BEGIN_SRC scheme :results output :session
(define (cube n) (* n n n))

(define (inc n) (+ n 1))

(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (simpsons-rule f a b n)
  (define h (/ (- b a) n))
  (define (yk k)
    (* (cond ((= k 0) 1)
             ((= k n) 1)
             ((even? k) 2)
             (else 4))
       (f (+ a (* k h)))))
  (* (/ h 3) (sum yk 0 inc n)))

(map display (list
              (simpsons-rule cube 0 1 100) "\n"
              (simpsons-rule cube 0 1 1000) "\n"))
#+END_SRC

#+RESULTS:
: 1/4
: 1/4

***** Exercise 1.30

*Exercise 1.30:* The `sum' procedure above generates a linear
recursion.  The procedure can be rewritten so that the sum is
performed iteratively.  Show how to do this by filling in the
missing expressions in the following definition:

#+BEGIN_SRC scheme
(define (sum term a next b)
  (define (iter a result)
    (if <??>
        <??>
        (iter <??> <??>)))
  (iter <??> <??>))
#+END_SRC

****** Solution

We start the iteration with =a= and a sum/result of =0=. For each iteration we check if we are after
=b=, if so we return the result, if not, we do another iteration with the next =a= and as the next
sum/result the sum of =(term a)= with the current sum/result:

#+BEGIN_SRC scheme
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ (term a) result))))
  (iter a 0))
#+END_SRC

***** Exercise 1.31

*Exercise 1.31:*
  a. The `sum' procedure is only the simplest of a vast number of
    similar abstractions that can be captured as higher-order
    procedures.(3)  Write an analogous procedure called `product'
    that returns the product of the values of a function at
    points over a given range.  Show how to define `factorial' in
    terms of `product'.  Also use `product' to compute
    approximations to [pi] using the formula(4)

#+BEGIN_SRC
pi   2 * 4 * 4 * 6 * 6 * 8 ...
-- = -------------------------
 4   3 * 3 * 5 * 5 * 7 * 7 ...
#+END_SRC

  b. If your `product' procedure generates a recursive process,
    write one that generates an iterative process.  If it
    generates an iterative process, write one that generates a
    recursive process.

****** Solution

a.

#+BEGIN_SRC scheme :results value :session
(define (product term a next b)
  (if (> a b)
      1
      (* (term a) (product term (next a) next b))))

(define (factorial n)
  (define (identity x) x)
  (define (inc n) (+ n 1))
  (product identity 1 inc n))

(define (pi n)
  (define (pi-term n)
    (* (/ n (+ n 1)) (/ (+ n 2) (+ n 1))))
  (define (pi-next n) (+ n 2))
  (* 4 (product pi-term 2 pi-next n)))

(and (= (factorial 0) 1)
     (= (factorial 1) 1)
     (= (factorial 2) 2)
     (= (factorial 3) 6)
     (= (factorial 4) 24)
     (= (* 1.0 (pi 10000)) 3.1417497057380523))
#+END_SRC

#+RESULTS:
: #t

b. We did a recursive procedure first, so here's the iterative version:

#+BEGIN_SRC scheme :results value :session
(define (product term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* result (term a)))))
  (iter a 1))

(define (factorial n)
  (define (identity x) x)
  (define (inc n) (+ n 1))
  (product identity 1 inc n))

(define (pi n)
  (define (pi-term n)
    (* (/ n (+ n 1)) (/ (+ n 2) (+ n 1))))
  (define (pi-next n) (+ n 2))
  (* 4 (product pi-term 2 pi-next n)))

(and (= (factorial 0) 1)
     (= (factorial 1) 1)
     (= (factorial 2) 2)
     (= (factorial 3) 6)
     (= (factorial 4) 24)
     (= (* 1.0 (pi 10000)) 3.1417497057380523))
#+END_SRC

#+RESULTS:
: #t

***** Exercise 1.32

*Exercise 1.32:*
a. Show that `sum' and `product' (*Note Exercise 1-31::) are
both special cases of a still more general notion called
`accumulate' that combines a collection of terms, using some
general accumulation function:

#+BEGIN_SRC scheme
(accumulate combiner null-value term a next b)
#+END_SRC

    `Accumulate' takes as arguments the same term and range
    specifications as `sum' and `product', together with a
    `combiner' procedure (of two arguments) that specifies how
    the current term is to be combined with the accumulation of
    the preceding terms and a `null-value' that specifies what
    base value to use when the terms run out.  Write `accumulate'
    and show how `sum' and `product' can both be defined as
    simple calls to `accumulate'.

  b. If your `accumulate' procedure generates a recursive process,
    write one that generates an iterative process.  If it
    generates an iterative process, write one that generates a
    recursive process.

****** Solution

a.

#+BEGIN_SRC scheme :results value :session
(define (accumulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (accumulate combiner null-value term (next a) next b))))

(define (product term a next b)
  (accumulate * 1 term a next b))

(define (sum term a next b)
  (accumulate + 0 term a next b))

(define (identity x) x)
(define (inc n) (+ n 1))

(define (factorial n)
  (product identity 1 inc n))

(define (nth-triangle-number n)
  (sum identity 0 inc n))

(and (= (factorial 0) 1)
     (= (factorial 1) 1)
     (= (factorial 2) 2)
     (= (factorial 3) 6)
     (= (factorial 4) 24)
     (= (nth-triangle-number 0) 0)
     (= (nth-triangle-number 1) 1)
     (= (nth-triangle-number 2) 3)
     (= (nth-triangle-number 3) 6)
     (= (nth-triangle-number 4) 10))
#+END_SRC

#+RESULTS:
: #t

b.

#+BEGIN_SRC scheme
(define (accumulate combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (combiner result (term a)))))
  (iter a null-value))
#+END_SRC

***** Exercise 1.33

*Exercise 1.33:* You can obtain an even more general version of
`accumulate' (*Note Exercise 1-32::) by introducing the notion of
a "filter" on the terms to be combined.  That is, combine only
those terms derived from values in the range that satisfy a
specified condition.  The resulting `filtered-accumulate'
abstraction takes the same arguments as accumulate, together with
an additional predicate of one argument that specifies the filter.
Write `filtered-accumulate' as a procedure.  Show how to express
the following using `filtered-accumulate':

  a. the sum of the squares of the prime numbers in the interval a
    to b (assuming that you have a `prime?' predicate already
    written)

  b. the product of all the positive integers less than n that are
    relatively prime to n (i.e., all positive integers i < n such
    that GCD(i,n) = 1).

****** Solution

a.

#+BEGIN_SRC scheme :results value :session
(define (next n)
  (if (= n 2)
      3
      (+ n 2)))

(define (divides? a b)
  (= (remainder b a) 0))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (filtered-accumulate filter combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a)
              (if (filter a)
                  (combiner result (term a))
                  result))))
  (iter a null-value))

(define (sum-of-squares-of-primes a b)
  (define (filter a)
    (prime? a))
  (define (term n)
    (* n n))
  (define (next n) (+ n 1))
  (filtered-accumulate filter + 0 term a next b))

(and (= (sum-of-squares-of-primes 2 6) 38)
     (= (sum-of-squares-of-primes 2 10) 87))
#+END_SRC

#+RESULTS:
: #t

b.

#+BEGIN_SRC scheme :results value :session
(define (filtered-accumulate filter combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a)
              (if (filter a)
                  (combiner result (term a))
                  result))))
  (iter a null-value))

  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
(define (product-of-relative-primes n)
  (define (filter a)
    (= (gcd a n) 1))
  (define (identity x) x)
  (define (next n) (+ n 1))
  (filtered-accumulate filter * 1 identity 1 next (- n 1)))

(and (= (product-of-relative-primes 3) 2)
     (= (product-of-relative-primes 5) 24)
     (= (product-of-relative-primes 10) 189))
#+END_SRC

#+RESULTS:
: #t

***** Exercise 1.34

*Exercise 1.34:* Suppose we define the procedure

#+BEGIN_SRC scheme
(define (f g)
    (g 2))
#+END_SRC

Then we have

#+BEGIN_SRC scheme
(f square)
4

(f (lambda (z) (* z (+ z 1))))
6
#+END_SRC

What happens if we (perversely) ask the interpreter to evaluate
the combination `(f f)'?  Explain.

****** Solution

The code would be expanded as follows:
#+BEGIN_SRC scheme
(f f)
(f 2)
(2 2)
#+END_SRC

It would result in an error because =2= is not a function:

#+BEGIN_SRC scheme :results output :session
(define (f g)
  (g 2))
(f f)
#+END_SRC

#+RESULTS:
:
: ;The object 2 is not applicable.
: ;To continue, call RESTART with an option number:
: ; (RESTART 4) => Specify a procedure to use in its place.
: ; (RESTART 3) => Return to read-eval-print level 3.
: ; (RESTART 2) => Return to read-eval-print level 2.
: ; (RESTART 1) => Return to read-eval-print level 1.
:
: 4 error>

**** 1.3.2 Constructing Procedures Using `Lambda'
***** let is a special form of lambda                             :drill:
SCHEDULED: <2021-03-19 Fri>
:PROPERTIES:
:ID:       83c53277-de77-40f0-8d43-c5defa73bef0
:DRILL_LAST_INTERVAL: 77.656
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-12-31 Thu 15:47]
:END:

scheme: =let= is actually a special form of <[lambda]>
Example:
<[
#+BEGIN_SRC scheme
(let ((a 3) (b 1))
  (+ a b))

((lambda (a b)
   (+ a b)) 3 1)
#+END_SRC
]>

**** 1.3.3 Procedures as General Methods
***** Exercise 1.35

*Exercise 1.35:* Show that the golden ratio [phi] (section *Note
1-2-2::) is a fixed point of the transformation x |-> 1 + 1/x, and
use this fact to compute [phi] by means of the `fixed-point'
procedure.

****** Solution

We have as a fixed point $x = 1 + \frac{1}{x}$ which means $x^2 - x - 1 = 0$. The solution being
$\frac{1 + \sqrt{5}}{2}$ which is equal to $\phi$.

Here is its approximation using the =fixed-point= procedure:

#+BEGIN_SRC scheme :results value :session
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0)
#+END_SRC

#+RESULTS:
: 1.6180327868852458

***** Exercise 1.36

*Exercise 1.36:* Modify `fixed-point' so that it prints the
sequence of approximations it generates, using the `newline' and
`display' primitives shown in *Note Exercise 1-22::.  Then find a
solution to x^x = 1000 by finding a fixed point of x |->
`log'(1000)/`log'(x).  (Use Scheme's primitive `log' procedure,
which computes natural logarithms.)  Compare the number of steps
this takes with and without average damping.  (Note that you
cannot start `fixed-point' with a guess of 1, as this would cause
division by `log'(1) = 0.)

****** Solution

#+BEGIN_SRC scheme :results output :session
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(define (average a b)
  (/ (+ a b) 2))

(fixed-point (lambda (y) (average y (/ (log 1000) (log y)))) 4.0)
(fixed-point (lambda (y) (/ (log 1000) (log y))) 4.0)
#+END_SRC

#+RESULTS:
#+begin_example
4.
4.491446071165521
4.544974650975552
4.553746974742814
4.555231425802502
4.555483906560562
4.5555268862194875
4.
4.9828921423310435
4.301189432497896
4.734933901055578
4.442378437719526
4.632377941509958
4.505830646780212
4.588735606875766
4.533824356566501
4.56993352418142
4.546075272637246
4.561789745175654
4.55141783665413
4.5582542120702625
4.553744140202578
4.556717747893265
4.554756404545319
4.5560497413912975
4.5551967522618035
4.555759257615811
4.555388284933278
4.555632929754932
4.555471588998784
4.555577989320218
4.555507819903776
4.555554095154945
4.555523577416557
4.555543703263474
4.555530430629037
#+end_example

***** Exercise 1.37

*Exercise 1.37:*
  a. An infinite "continued fraction" is an expression of the form

                    N_1
          f = ---------------------
                        N_2
              D_1 + ---------------
                            N_3
                    D_2 + ---------
                          D_3 + ...

    As an example, one can show that the infinite continued
    fraction expansion with the n_i and the D_i all equal to 1
    produces 1/[phi], where [phi] is the golden ratio (described
    in section *Note 1-2-2::).  One way to approximate an
    infinite continued fraction is to truncate the expansion
    after a given number of terms.  Such a truncation--a
    so-called finite continued fraction "k-term finite continued
    fraction"--has the form

                N_1
          -----------------
                    N_2
          D_1 + -----------
                ...    N_K
                    + -----
                      D_K

    Suppose that `n' and `d' are procedures of one argument (the
    term index i) that return the n_i and D_i of the terms of the
    continued fraction.  Define a procedure `cont-frac' such that
    evaluating `(cont-frac n d k)' computes the value of the
    k-term finite continued fraction.  Check your procedure by
    approximating 1/[phi] using

          (cont-frac (lambda (i) 1.0)
                    (lambda (i) 1.0)
                    k)

    for successive values of `k'.  How large must you make `k' in
    order to get an approximation that is accurate to 4 decimal
    places?

  b. If your `cont-frac' procedure generates a recursive process,
    write one that generates an iterative process.  If it
    generates an iterative process, write one that generates a
    recursive process.

****** Solution

a.

k needs to be at least equal to 11 in order to have an approximation that is accurate to 4 decimal
places.

#+BEGIN_SRC scheme :results output :session
(define (cont-frac n d k)
  (define (frac i)
    (if (> i k)
        0
        (/ (n i) (+ (d i) (frac (+ i 1))))))
  (frac 1))

(display (cont-frac (lambda (i) 1.0)
                    (lambda (i) 1.0)
                    10))
(newline)
(display (cont-frac (lambda (i) 1.0)
                    (lambda (i) 1.0)
                    11))
#+END_SRC

#+RESULTS:
: .6179775280898876
: .6180555555555556

b.

Here is the iterative version:

#+BEGIN_SRC scheme :results output :session
(define (cont-frac n d k)
  (define (loop i result)
    (if (< i 1)
        result
        (loop (- i 1) (/ (n i) (+ (d i) result)))))
  (loop k 0))

(display (cont-frac (lambda (i) 1.0)
                    (lambda (i) 1.0)
                    11))
#+END_SRC

#+RESULTS:
: .6180555555555556

***** Exercise 1.38

*Exercise 1.38:* In 1737, the Swiss mathematician Leonhard Euler
published a memoir `De Fractionibus Continuis', which included a
continued fraction expansion for e - 2, where e is the base of the
natural logarithms.  In this fraction, the n_i are all 1, and the
D_i are successively 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, ....  Write
a program that uses your `cont-frac' procedure from *Note Exercise
1-37:: to approximate e, based on Euler's expansion.

****** Solution

#+BEGIN_SRC scheme :results value :session
(define (cont-frac n d k)
  (define (frac i)
    (if (> i k)
        0
        (/ (n i) (+ (d i) (frac (+ i 1))))))
  (frac 1))

(cont-frac (lambda (i) 1.0)
           (lambda (i)
             (cond ((= (remainder i 3) 2) (- i (quotient i 3)))
                   (else 1)))
           1000)
#+END_SRC

#+RESULTS:
: 0.7182818284590453

***** Exercise 1.39

*Exercise 1.39:* A continued fraction representation of the
tangent function was published in 1770 by the German mathematician
J.H. Lambert:

                  x
    tan x = ---------------
                    x^2
            1 - -----------
                      x^2
                3 - -------
                    5 - ...

where x is in radians.  Define a procedure `(tan-cf x k)' that
computes an approximation to the tangent function based on
Lambert's formula.  `K' specifies the number of terms to compute,
as in *Note Exercise 1-37::.

****** Solution

#+BEGIN_SRC scheme :results value :session
(define (cont-frac n d k)
  (define (frac i)
    (if (> i k)
        0
        (/ (n i) (+ (d i) (frac (+ i 1))))))
  (frac 1))

(define (tan-cf x k)
  (cont-frac (lambda (i) (if (= i 1)
                             x
                             (* -1 x x)))
             (lambda (i) (- (* i 2) 1))
             k))

(exact->inexact (tan-cf 42 100))
#+END_SRC

#+RESULTS:
: 2.2913879924374863

* Practical Vim, Second Edition, Edit Text at the Speed of Thought
:PROPERTIES:
:SOURCE: Practical Vim, Second Edition, Edit Text at the Speed of Thought
:END:

** Tip 1: Meet the Dot Command
*** .                                                               :drill:
SCHEDULED: <2021-09-12 Sun>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       c4939665-f081-4940-a37c-f7e66e994b8b
:DRILL_LAST_INTERVAL: 468.4349
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-06-01 Mon 09:56]
:END:

vim: <[Repeat the last change]> with <[.]>

** Tip 2: Don’t Repeat Yourself

Clear a character and enter Insert mode with =s=

*** S                                                               :drill:
SCHEDULED: <2022-01-28 Fri>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       faf68228-ea4f-4e5d-a866-4882306e5f40
:DRILL_LAST_INTERVAL: 449.1113
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.285
:DRILL_EASE: 1.8
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-11-05 Thu 11:04]
:END:

vim: <[Clear the whole line and enter Insert mode]> with <[S]>

** Tip 3: Take One Step Back, Then Three Forward
*** ;                                                               :drill:
SCHEDULED: <2021-06-30 Wed>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       68a12ba1-2022-4fe6-9a82-32c7e5ea232a
:DRILL_LAST_INTERVAL: 419.0875
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-05-07 Thu 10:50]
:END:

vim: <[Repeat the last find]> with <[;]>

** Tip 4: Act, Repeat, Reverse
*** ,                                                               :drill:
SCHEDULED: <2021-09-10 Fri>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       a68a0891-f245-487d-a63a-0a8391c8feed
:DRILL_LAST_INTERVAL: 439.7622
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.901
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-06-27 Sat 13:16]
:END:

vim: <[Repeat the last *Find* in the opposite direction]> with <[,]>

*** &                                                               :drill:
SCHEDULED: <2021-05-24 Mon>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       204c0f1b-0031-4874-90a8-656e4b662088
:DRILL_LAST_INTERVAL: 289.3305
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.091
:DRILL_EASE: 1.62
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-08-08 Sat 09:24]
:END:

vim: <[Repeat the last substitute]> with <[&]>

** Tip 5: Find and Replace by Hand

Find and replace manually with =n= and =.=

** Tip 6: Meet the Dot Formula
*** The Dot Formula                                                 :drill:
SCHEDULED: <2021-08-08 Sun>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       686ad2c7-f6e1-474b-bda7-0008b27efc6e
:DRILL_LAST_INTERVAL: 435.4435
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-05-30 Sat 13:13]
:END:

vim: <[The *Dot Formula*]> consists in using <[one key to move and one key to
execute]>

** Tip 7: Pause with Your Brush Off the Page

Normal mode is the natural resting state just like a painter rarely applies his
brush on the canvas.

** Tip 8: Chunk Your Undos

Switching to Normal mode more or less often allows you to have a more or less
granular control of the undos.

** Tip 9: Compose Repeatable Changes

Try to make all your changes repeatable so that you can use the dot command when
needed.

*** a vs i                                                          :drill:
SCHEDULED: <2021-06-14 Mon>
:PROPERTIES:
:ID:       bca43c41-e0c9-41ab-9b3a-33faf360228c
:DRILL_LAST_INTERVAL: 400.254
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-05-10 Sun 11:59]
:END:

vim: The difference between the text object selection *a* and *i* is that *a*
<[selects the surrounding characters]>

** Tip 10: Use Counts to Do Simple Arithmetic
*** Decrementing Numbers                                            :drill:
SCHEDULED: <2021-12-20 Mon>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       7621832B-2947-4CA8-A3EB-6D716AC7CC71
:DRILL_LAST_INTERVAL: 354.3774
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 14
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.643
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-12-31 Thu 15:41]
:END:

vim: <[Decrement the next number on the line]> with <[<C-x>]>

*** Incrementing Numbers                                            :drill:
SCHEDULED: <2022-05-05 Thu>
:PROPERTIES:
:ID:       DA568555-6484-4A00-8E61-D0335AA9C45B
:DRILL_LAST_INTERVAL: 685.8778
:DRILL_CARD_TYPE: show1cloze
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-06-18 Thu 11:25]
:END:

vim: <[Increment the next number on the line]> with <[<C-a>]>

*** Prefix C-x or C-a                                               :drill:
SCHEDULED: <2021-04-16 Fri>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       6cc13d2a-fce7-4153-b485-6fc8d3d04c56
:DRILL_LAST_INTERVAL: 345.9004
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-05-05 Tue 08:16]
:END:

vim: <[*Prefix* <C-x> or <C-a> with a *number*]> to <[decrement or increment the
next number on the line by that number]>

** Tip 11: Don’t Count If You Can Repeat

Prefer the dot command over using counted modifications because it is easier and
more flexible.

** Tip 12: Combine and Conquer

Use operator + motion when possible.

*** Operator-Pending Mode                                           :drill:
SCHEDULED: <2022-04-06 Wed>
:PROPERTIES:
:ID:       2de6267a-6faa-486e-a114-e025306ecddf
:DRILL_LAST_INTERVAL: 573.9516
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-09-09 Wed 11:42]
:END:

vim: The mode in which you are after typing an operator (eg. =d=) is called
<[Operator-Pending Mode]>

** Tip 13: Make Corrections Instantly from Insert Mode
*** <C-h>                                                              :drill:
SCHEDULED: <2021-04-06 Tue>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       fea6fa70-b7a5-48fb-9bd4-b0e3bb06b1ce
:DRILL_LAST_INTERVAL: 156.1975
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 20
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.699
:DRILL_EASE: 2.34
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-11-01 Sun 09:44]
:END:

vim: <[Delete back one character in insert mode]> with <[<C-h>]>

** Tip 14: Get Back to Normal Mode

Enter *Insert Normal Mode* with =<C-o>= which is a mode that accepts a Normal
Mode command and immediately returns to Insert Mode.

*** zz                                                              :drill:
SCHEDULED: <2021-03-07 Sun>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       52dcc269-bec8-467a-9ce1-c78af7dbb176
:DRILL_LAST_INTERVAL: 100.7452
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 17
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.412
:DRILL_EASE: 1.62
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-11-26 Thu 12:39]
:END:

vim: <[*Center* the current line]> with <[zz]>

** Tip 15: Paste from a Register Without Leaving Insert Mode

Paste from Insert Mode with =<C-r>{Register}=.
Paste from Insert Mode and fix the indent with =<C-r><C-p>{Register}=.

** Tip 16: Do Back-of-the-Envelope Calculations in Place

Use ~<C-r>=~ to insert the result of an expression.

** Tip 17: Insert Unusual Characters by Character Code

Insert an unusual character with =<C-v>{123}= or =<C-v>u{1234}= where 1234 is an
unicode point.
Get the decimal and hexadecimal value of the character under the
cursor with =ga=.

*** C-v{nondigit}                                                   :drill:
SCHEDULED: <2021-12-26 Sun>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       241b2c74-4d8a-4539-ba3c-a749d3d115fd
:DRILL_LAST_INTERVAL: 516.2052
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-07-28 Tue 08:35]
:END:

vim: <[Insert a character literally]> with <[<C-v>{char}]>

** Tip 18: Insert Unusual Characters by Digraph

Insert Unusual Characters by Digraph with =<C-k>{char1}{char2}=

** Tip 19: Overwrite Existing Text with Replace Mode

Replace characters with =R=.

Replace "virtual" characters with =gR=. This would replace a tab character as if
it consisted of spaces.

** Tip 20: Grok Visual Mode

You can use all the same motions and operators in Visual than in Normal mode.

Switch between Visual and Select mode with =<C-g>=.

** Tip 21: Define a Visual Selection

Do a character-wise selection with =v=.
Do a line-wise selection with =V=.
Do a block-wise selection with =<C-v>=.
Reselect the last visual selection with =gv=.

*** =o= while selecting                                             :drill:
SCHEDULED: <2021-03-30 Tue>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       32c9c9d4-80c9-4849-af8e-059f39b12cf6
:DRILL_LAST_INTERVAL: 136.1967
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 15
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.266
:DRILL_EASE: 1.76
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-11-14 Sat 13:30]
:END:

vim: selection: <[Go to the other end of the selection]> with <[o]>

** Tip 22: Repeat Line-Wise Visual Commands

Use the dot command to repeat an action made on a line-wise selection.

** Tip 23: Prefer Operators to Visual Commands Where Possible

Because when a Visual mode command is repeated, it affects the same range of
text, you should prefer the operators.

** Tip 24: Edit Tabular Data with Visual-Block Mode
** Tip 25: Change Columns of Text

Use Visual Block Mode to change text over several lines when the modification
needed is aligned.

** Tip 26: Append After a Ragged Visual Block

Use =I= or =A= to insert or append at the beginning or end of lines that are
block selected. (Actually this works with line-wise selection too. And line-wise
selection is simpler/clearer in this context.)

** Tip 27: Meet Vim’s Command Line

Enter Command-Line Mode with =:=.
Execute an Ex Command on all lines that match a pattern with
=:[range]g[lobal]/{pattern}/[cmd]=.
Execute a Normal command on a range with =:[range]norm[al] {commands}=.

*** C-r{register}                                                   :drill:
SCHEDULED: <2021-05-20 Thu>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       2301cb16-42c4-47af-87d1-a2a986c2c6a1
:DRILL_LAST_INTERVAL: 197.6557
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 12
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.166
:DRILL_EASE: 1.34
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-11-03 Tue 11:04]
:END:

vim: <[Insert the content of a Register]> with <[=<C-r>{register}=]>

*** C-r{register} at the Command Line or in Insert Mode             :drill:
SCHEDULED: <2021-02-07 Sun>
:PROPERTIES:
:ID:       ce4f14d6-72d9-4443-872c-da0845a52237
:DRILL_LAST_INTERVAL: 125.2829
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.6
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-10-05 Mon 10:17]
:END:

vim: =<C-r>{register}= can be used from the <[Command Line]> or in <[Insert Mode]>

** Tip 28: Execute a Command on One or More Consecutive Lines

Execute an Ex Command on a specific line with =:{number}{command}=.
Execute an Ex Command on a range of lines with =:{start},{end}{command}=.
Execute an Ex Command on a range of lines by patterns with
=:/{start}/,/{end}/{command}=.
Offset the addresses with ={address}(-|+){number}=.

In Ex Commands addresses:
- =.= represents the current line
- =$= represents the end of file
- =%= represents the whole file
- ='{mark}= represents the line containing the mark

** Tip 29: Duplicate or Move Lines Using ‘:t’ and ‘:m’ Commands
** Tip 30: Run Normal Mode Commands Across a Range

Run Normal Mode Commands Across a Range with =:[range]normal COMMAND=.
=%= as a range represents the whole file.

** Tip 31: Repeat the Last Ex Command

Repeat the last Ex command with =@:= and =@@= after that.

** Tip 32: Tab-Complete Your Ex Commands

Complete Ex commands with =TAB= or =<C-d>=.

** Tip 33: Insert the Current Word at the Command Prompt
*** Insert the Current Word at the Command Prompt with =<C-r><C-w>=    :drill:
SCHEDULED: <2021-03-12 Fri>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       0e56efe4-aca9-4732-9aaa-ade5f96a2e66
:DRILL_LAST_INTERVAL: 156.4184
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 18
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.445
:DRILL_EASE: 1.86
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-10-07 Wed 13:55]
:END:

vim: <[Insert the Current Word at the Command Prompt]> with <[<C-r><C-w>]>

*** Insert the Current Whole WORD at the Command Prompt with =<C-r><C-a>= :drill:
SCHEDULED: <2021-01-25 Mon>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       ae4476b5-de5c-4105-bd4b-f49c34a3f2e8
:DRILL_LAST_INTERVAL: 3.874
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 21
:DRILL_FAILURE_COUNT: 6
:DRILL_AVERAGE_QUALITY: 3.287
:DRILL_EASE: 1.96
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-21 Thu 09:31]
:END:

vim: <[Insert the Current Whole WORD at the Command Prompt]> with <[<C-r><C-a>]>

**** Tip

<C-a> like <C-All>

** Tip 34: Recall Commands from History

Open the Ex commands Command-Line window with =q:=.
Open the search history Command-Line window with =q/=.
Switch from the Command-Line mode to the Command-Line window with =<C-f>=.

** Tip 35: Run Commands in the Shell

Execute shell commands with =:!{cmd}=.
Use =%= in a shell command to insert the filename.
Execute a shell with =:shell=.
Get back to the original shell while letting vim run with =<C-z>=. Get back to vim
with =fg=.
Write the output of a command to the current file with =:read !{cmd}=.
Pipe the content of the file to a command with =:[range]write !{cmd}=.
Filter a part of the file through a command with =:[range]!{cmd}=
Drop into Command-Line mode with the range prepopulated with =!{motion}= from
Normal mode.

** Tip 36: Run Multiple Ex Commands as a Batch

Use =:source {script}= to execute a script containing Ex commands.
Execute a Ex command on all the vim argument files with =:argdo {cmd}=.

** Tip 37: Track Open Files with the Buffer List

List the buffers with =:ls=.
In the listing the =%= symbol represents the actual visible buffer.
In the listing the =#= symbol represents the alternate buffer.
Switch to the alternate buffer with =<C-^>=.
Switch to the first buffer with =:bfirst=.
Switch to the previous buffer with =:bprevious=.
Switch to the next buffer with =:bnext=.
Switch to the last buffer with =:blast=.
Switch to the N buffer with =:b N=.
Switch to a buffer with its partial name with =:b {buffer_name}=.
Execute an Ex command on all the buffers with =:bufdo {cmd}=.
Delete buffers with =:bdelete N1 N2 N3...= or =:N,M bdelete=.

** Tip 38: Group Buffers into a Collection with the Argument List

List vim's arguments with =:args=.
Set the argument list with =:args {list}= where =list= can be a file name, a
wildcard expression, or a shell command enclosed in backticks.

** Tip 39: Manage Hidden Files

In the buffer list the =h= symbol represents hidden buffers.
In the buffer list the =a= symbol represents the active buffer.
Use =:set hidden= in order not to be bothered about unsaved buffers when using
=:argdo=, =:bufdo= or =:cfdo=.

** Tip 40: Divide Your Workspace into Split Windows

Split the window horizontally with =<C-w>s= or =:sp[lit] [file]=.
Split the window vertically with =<C-w>v= or =:vs[plit] [file]=.

Cycle between open windows with =<C-w>w=.
Focus the window to the left with =<C-w>h=.
Focus the window below with =<C-w>j=.
Focus the window above with =<C-w>k=.
Focus the window to the right with =<C-w>l=.
For the five keybindings above, the =<C-w>= key can be followed by any number of
=<C-[whjkl]>= key that will do the associated action.

Close the active window with =<C-w>c= or =:clo[se]=.
Keep only the active window, closing all others with =<C-w>o= or =:on[ly]=.

Equalize width and height of all windows with =<C-w>==.
Maximize height of the active window with =<C-w>_=.
Maximize width of the active window with =<C-w>|=.
Set active window height to [N] rows with =[N]<C-w>_=.
Set active window width to [N] columns with =[N]<C-w>|=.

** Tip 41: Organize Your Window Layouts with Tab Pages

Open {filename} in a new tab with =:tabe[dit] {filename}=.
Move the current window into its own tab with =<C-w>T=.
Close the current tab page and all of its windows with =:tabc[lose]=.
Keep the active tab page, closing all others with =:tabo[nly]=.
Switch to tab page number {N} with =:tabn[ext] {N}= or ={N}gt=.
Switch to the next tab page with =:tabn[ext]= or =gt=.
Switch to the previous tab page with =:tabp[revious]= or =gT=.
Move the current tab page with =:tabmove [N]=.

** Tip 42: Open a File by Its Filepath Using ‘:edit’

Print the Working Directory with =:pwd=.
Open a file relatively to the current working directory with =:edit {filename}=.
Open a file relatively to the current buffer file directory with
=:edit %[<TAB>]{filename}=.
Open a file relatively to the current buffer file directory without the current
filename with =:edit %:h[<TAB>]{filename}=.

** Tip 43: Open a File by Its Filename Using ‘:find’

Find file by filenames with =:find {name}=.
Set the path searched by =:find= with =:set path\={path}=.

** Tip 44: Explore the File System with netrw

Open file explorer for the current working directory with =:e[dit] .=.
Open file explorer for the directory of the active buffer with =:E[xplore]=.

** Tip 45: Save Files to Nonexistent Directories

Echo the current buffer name and status with =<C-g>=.
Create the directory of the current file with =:!mkdir %:h=. =%:h= represents
the current file directory.

** Tip 46: Save a File as the Super User

Write a file as root with =:w !sudo tee % > /dev/null=.
The =:w !{cmd}= command pipes the buffer to the standard input of the command
specified.
=%= represents the current file path.

** Tip 47: Keep Your Fingers on the Home Row

Keep your fingers on the Home Row and use the hjkl keys to move around.

** Tip 48: Distinguish Between Real Lines and Display Lines

Enable the number (line number) setting in order to distinguish real and display
lines more easily.
Prefix the following commands with =g= in order to act on display line rather
than real lines: =j=, =k=, =0=, =^= and =$=.

** Tip 49: Move Word-Wise

Move forward to start of next word with =w=.
Move forward to start of next WORD with =W=.
Move backward to start of current/previous word with =b=.
Move backward to start of current/previous WORD with =B=.
Move forward to end of current/next word with =e=.
Move forward to end of current/next WORD with =E=.

A word is defined as a sequence of letters, digits, and underscores, or as a
sequence of other nonblank characters separated with whitespace. A WORD is
defined as a sequence of nonblank characters separated with whitespace.

*** =ge=                                                            :drill:
SCHEDULED: <2021-08-24 Tue>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       97935b59-bf44-43d4-85c9-b96bc23357ac
:DRILL_LAST_INTERVAL: 242.2068
:DRILL_REPEATS_SINCE_FAIL: 9
:DRILL_TOTAL_REPEATS: 13
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.308
:DRILL_EASE: 1.52
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-12-25 Fri 15:27]
:END:

vim: <[Move to the end of the previous word]> with <[=ge=]>

*** =gE=                                                            :drill:
SCHEDULED: <2022-06-29 Wed>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       1c05c1b9-4866-4d3a-803f-f46973b7b745
:DRILL_LAST_INTERVAL: 534.1899
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.572
:DRILL_EASE: 2.08
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-11 Mon 08:35]
:END:

vim: <[Move to the end of the previous WHOLE WORD]> with <[=gE=]>

** Tip 50: Find by Character

Move forward to the next occurrence of {char} with =f{char}=.
Move backward to the previous occurrence of {char} with =F{char}.=.
Move forward to the character before the next occurrence of {char} with =t{char}=.
Move backward to the character after the previous occurrence of {char} with =T{char}=.
Repeat the last character-search command with =;=.
Reverse the last character-search command with =,=.

Jump in the middle of a word if the character you jump to is less likely to
occur elsewhere.

** Tip 51: Search to Navigate

Move around with the search command.
Use the search motion without the visual selection because the search motion
is exclusive while the visual selection by default is not.

*** Use the Search Command to Move Around                           :drill:
SCHEDULED: <2021-03-22 Mon>
:PROPERTIES:
:ID:       4a83776b-8744-448f-9eb2-146d33d8503f
:DRILL_LAST_INTERVAL: 78.5539
:DRILL_REPEATS_SINCE_FAIL: 15
:DRILL_TOTAL_REPEATS: 24
:DRILL_FAILURE_COUNT: 5
:DRILL_AVERAGE_QUALITY: 2.917
:DRILL_EASE: 1.16
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-02 Sat 16:11]
:END:

vim: best practice: Use the Search Command to Move Around

*** Use the Search Command to Modify                                :drill:
SCHEDULED: <2021-02-03 Wed>
:PROPERTIES:
:ID:       bab505de-ced6-49aa-aa6b-e65c9a642d9d
:DRILL_LAST_INTERVAL: 15.1162
:DRILL_REPEATS_SINCE_FAIL: 11
:DRILL_TOTAL_REPEATS: 66
:DRILL_FAILURE_COUNT: 13
:DRILL_AVERAGE_QUALITY: 2.802
:DRILL_EASE: 1.16
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-19 Tue 08:50]
:END:

vim: best practice: Use the Search Command to Modify (after an operator)

*** Exclusive vs Inclusive                                          :drill:
SCHEDULED: <2021-08-31 Tue>
:PROPERTIES:
:ID:       f471a709-397c-4fc2-bd94-794c17d47bd8
:DRILL_LAST_INTERVAL: 419.6875
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-07-07 Tue 10:36]
:END:

vim: An *Exclusive* Character Motion means that the motion will include
<[only the start position]>
vim: An *Inclusive* Character Motion means that the motion will include
<[the start and end positions]>

*** / is Exclusive                                                  :drill:
SCHEDULED: <2022-05-06 Fri>
:PROPERTIES:
:ID:       9fe75d4a-fc16-47a7-b982-f54f0f834903
:DRILL_LAST_INTERVAL: 484.621
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.429
:DRILL_EASE: 1.94
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-06 Wed 19:05]
:END:

vim: The =/= motion is <[Exclusive||Exclusive or Inclusive]> in its selection

** Tip 52: Trace Your Selection with Precision Text Objects
*** Text Object Motion vs Text Object Selection                     :drill:
SCHEDULED: <2021-03-05 Fri>
:PROPERTIES:
:ID:       9e178e0f-5ebf-49fb-944e-c0e731ba2447
:DRILL_LAST_INTERVAL: 184.3521
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 18
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.721
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-09-02 Wed 12:21]
:END:

vim: =(= is called a <[Text Object Motion]> while
    =a(= is called a <[Text Object Selection]>

*** =(=                                                             :drill:
SCHEDULED: <2021-08-18 Wed>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       dd09704b-0bba-4c2a-a9a4-5ece4ec46416
:DRILL_LAST_INTERVAL: 406.4062
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-07-08 Wed 10:16]
:END:

vim: <[Move a sentence backward]> with <[(]>

*** =)=                                                             :drill:
SCHEDULED: <2021-06-16 Wed>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       ff055d09-298d-4d9f-a304-7d5bb19ad849
:DRILL_LAST_INTERVAL: 173.4642
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 12
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.417
:DRILL_EASE: 1.8
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-12-25 Fri 15:19]
:END:

vim: <[Move a sentence forward]> with <[)]>

*** ={=                                                             :drill:
SCHEDULED: <2021-10-09 Sat>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       12dbf654-358f-4759-b51b-71684ac59c46
:DRILL_LAST_INTERVAL: 435.4435
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-07-31 Fri 12:49]
:END:

vim: <[Move a paragraph backward]> with <[{]>

*** =}=                                                             :drill:
SCHEDULED: <2021-08-18 Wed>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       4c30df8e-c0c6-4b87-8e82-fcfd2ffb825f
:DRILL_LAST_INTERVAL: 406.4062
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-07-08 Wed 10:14]
:END:

vim: <[Move a paragraph forward]> with <[}]>

*** =as=                                                            :drill:
SCHEDULED: <2021-08-18 Wed>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       6e5c1cd3-83bc-4a12-93d8-9a4c6120ae2b
:DRILL_LAST_INTERVAL: 406.4062
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-07-08 Wed 10:16]
:END:

vim: <[Select a sentence]> with <[as]>

*** =ap=                                                            :drill:
SCHEDULED: <2021-06-07 Mon>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       043d2dbc-f404-4f3a-8c12-701bd315533d
:DRILL_LAST_INTERVAL: 342.7486
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-06-29 Mon 10:53]
:END:

vim: <[Select a paragraph]> with <[ap]>

*** =a[=                                                            :drill:
SCHEDULED: <2021-10-24 Sun>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       ce142f5e-219f-45d0-a1a9-90179dbf0d8f
:DRILL_LAST_INTERVAL: 449.624
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-07-31 Fri 12:50]
:END:

vim: <[Select a "[" block]> with <[a[]>

*** =a<=                                                            :drill:
SCHEDULED: <2021-10-09 Sat>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       d923e014-b59f-4ac5-8c68-b5a5938a94a8
:DRILL_LAST_INTERVAL: 432.3306
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.889
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-08-03 Mon 11:53]
:END:

vim: <[Select a "<" block]> with <[a<]>

*** =a(= or =ab=                                                    :drill:
SCHEDULED: <2021-10-24 Sun>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       f9b54363-47e0-43c6-bf7b-bf4bcb1145f7
:DRILL_LAST_INTERVAL: 449.624
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-07-31 Fri 12:51]
:END:

vim: <[Select a "(" block]> with <[ab or a(||X OR Y]>

*** =a{= or =aB=                                                    :drill:
SCHEDULED: <2021-08-18 Wed>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       9698e753-b6ee-4292-a672-3c7458a54c27
:DRILL_LAST_INTERVAL: 406.4062
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-07-08 Wed 10:14]
:END:

vim: <[Select a "{" block]> with <[aB or a{||X OR Y]>

*** =at=                                                            :drill:
SCHEDULED: <2021-04-26 Mon>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       4e0a7298-a353-4ce0-a9e7-ff8ca2d5d98c
:DRILL_LAST_INTERVAL: 165.1867
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 14
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.714
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-11-12 Thu 11:58]
:END:

vim: <[Select an html tag]> with <[at]>

** Tip 53: Delete Around, or Change Inside

Prefer the text-object selections =a{selection}= when deleting for cleaner
results because the appropriate spaces around the word will be deleted.
Prefer the text-object selections =i{selection}= when changing for a simpler
modification because the spaces around the word won't be included.

** Tip 54: Mark Your Place and Snap Back to It

Mark a position with =m{letter}=. A lowercase letter can only local the current
buffer. An uppercase letter can be used across buffers.

Go to the line of the specified mark with ='{letter}=.
Go to the line and column of the specified mark with =`{letter}=.

Go to the position before the last jump within current file with =``=.
Go to the location of last change with =`.=.
Go to the location of last insertion with =`^=.
Go to the start of last change or yank with =`[=.
Go to the end of last change or yank with =`]=.
Go to the start of last visual selection with =`<=.
Go to the end of last visual selection with =`>=.

** Tip 55: Jump Between Matching Parentheses

Natively, in order to change surrounding braces to another brace symbol, jump to
the matching brace first with =%=, then replace it, then jump back with =<C-o>=
or =``= and replace the first one.
Otherwise you can install the [[https://github.com/tpope/vim-surround][vim-surround]] plugin and use
=cs{old_char}{new_char}=.

Enable the /matchit/ plugin so that =%= can jump between more matching keywords
(eg. HTML tags or Ruby def/end)

*** =%=                                                             :drill:
SCHEDULED: <2022-03-27 Sun>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       aa91ab44-ab79-4c79-b35a-b9449503ee33
:DRILL_LAST_INTERVAL: 549.1395
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-09-24 Thu 13:32]
:END:

vim: <[Go to the *Matching* or *Surrounding* Brace||X or Y]> with <[=%=]>

** Tip 56: Traverse the Jump List

Jump backward in the Jump List with =<C-o>=.
Jump forward in the Jump List with =<C-i>=.
Jump to line number with =[count]G=.
Jump to top/middle/bottom of screen with =H=, =M= and =L=.
Jump to file name under the cursor with =gf=.
Jump to definition of keyword under the cursor with =<C-]>= or =:tab {name}=.

** Tip 57: Traverse the Change List

See the Change List with =:changes=.

*** =g;=                                                            :drill:
SCHEDULED: <2021-01-22 Fri>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       49ef65b3-7db5-4c15-9d63-ed6792af15fd
:DRILL_LAST_INTERVAL: 14.8837
:DRILL_REPEATS_SINCE_FAIL: 11
:DRILL_TOTAL_REPEATS: 51
:DRILL_FAILURE_COUNT: 8
:DRILL_AVERAGE_QUALITY: 3.196
:DRILL_EASE: 1.16
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-07 Thu 09:07]
:END:

vim: <[Go to the next older change position]> with <[=g;=]>

*** =g,=                                                            :drill:
SCHEDULED: <2021-06-14 Mon>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       324e28c5-c60c-4647-8097-9bfa811bde44
:DRILL_LAST_INTERVAL: 279.9535
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.222
:DRILL_EASE: 1.8
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-09-07 Mon 09:16]
:END:

vim: <[Go to the next newer change position]> with <[=g,=]>

*** =gi=                                                            :drill:
SCHEDULED: <2021-02-07 Sun>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       0bb85849-f6cc-4c2e-9e16-8ebe022c8d8f
:DRILL_LAST_INTERVAL: 261.2669
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-05-22 Fri 09:01]
:END:

vim: <[Get back to insertion mode at the place of last insertion]> with <[=gi=]>
** Tip 58: Jump to the Filename Under the Cursor

Jump to the filename under the cursor with =gf=.
Make vim automatically try to append to a filename with
=:set suffixesadd+={extension}=.
Extend the directories Vim inspects for opening files with
=:set path={dir},[,...]=.
In the path variable =.= will stand for the directory of the current file and
the empty string will stand for the current working directory.
You should install plugins that set these up automatically for you (eg. for ruby
[[https://github.com/tpope/vim-bundler][vim-bundler]] or [[https://github.com/vim-ruby/vim-ruby][vim-ruby]])

** Tip 59: Snap Between Files Using Global Marks

Use global marks (uppercase letter marks) to quickly switch between files.

** Tip 60: Delete, Yank, and Put with Vim’s Unnamed Register

The delete =d=, yank =y= and put =p= commands all act on the Unamed Register by
default.
The commands intelligently act character or line-wise.

** Tip 61: Grok Vim’s Registers

Prefix the delete, yank and put commands with ="{char}= to use a different
register than the unamed one.
The unnamed register is =""=.
The expression register is ="==.
The name of the alternate file is ="#=.
The system clipboard register is ="+=
The system primary selection register is ="*=
The current file name register is ="%=
The black hole register is ="_=
The last inserted text is =".=.
The last ex command is =":=.
The last search is ="/=.
There is 26 generic registers you can use with ="{letter}= where the letter if
lowercase will overwrite the content of the register, and uppercase letters will
append to it.

*** ="0= Register                                                   :drill:
SCHEDULED: <2021-02-22 Mon>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       6d656590-90ea-4e1a-8cc5-eaa80060810f
:DRILL_LAST_INTERVAL: 95.9163
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 16
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.438
:DRILL_EASE: 1.76
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-11-18 Wed 08:43]
:END:

vim: Use the <[Yank]> register with <[="0=]>

** Tip 62: Replace a Visual Selection with a Register

Replace X with Y by copying Y, visually selecting X and using the =p= command
without having to specify a register.
In this instance the =p= command will replace the content of the unnamed
register, and the ="0= (yank) register will need to be used next.
Use a similar technique to swap other stuff. Also use a mark =m{letter}= to jump
back to the first item place.

** Tip 63: Paste from a Register

Use =<C-r>{register}= from Insert Mode to paste from a register.
Paste before the cursor and place the cursor just after the pasted text with
=gP=.
Paste after the cursor and place the cursor just after the pasted text with
=gp=.

** Tip 64: Interact with the System Clipboard

Use =:set paste= to tell Vim that you are about to paste something and that it
should not autoindent.
Otherwise you can directly use the System Clipboard register ="+= which does not
suffer from this problem.

** Tip 65: Record and Execute a Macro

Record a new Macro by typing =q{register}=, typing the macro content, and
finally saving it with =q=.
Check the content of the Macro with =:reg {register}=.
Invoke a Macro with =@{register}=.

*** =@@=                                                            :drill:
SCHEDULED: <2021-08-02 Mon>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       aa65070d-00ae-490d-8f55-4d0aedaa826f
:DRILL_LAST_INTERVAL: 291.5825
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.546
:DRILL_EASE: 2.04
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-10-14 Wed 11:22]
:END:

vim: <[Invoke the Last Called Macro]> with <[=@@=]>

** Tip 66: Normalize, Strike, Abort

Be precise in your motion when recording macros. It's better to be more verbose.

Easily repeat the macro by prefixing it with a count, like so ={count}@{macro}=.
You can overshoot with the count, and in most cases it won't matter because the
repetition will stop when Vim fails to execute a command from the macro.

** Tip 67: Play Back with a Count

An easy way to repeat the Dot Formula multiple times is to record one in a
macro, and then executing the macro with a count like so:
={movement}{action}qq;.q{count}@=.
A count of 22 is easy to type because it uses the same key as the =@= key on a
qwerty keyboard.

** Tip 68: Repeat a Change on Contiguous Lines

Execute a macro in series by executing it with a count.
The whole run can fail if one of the macro instance fails to execute.

Execute a macro in parallel by using the =:normal= Ex Command, like so
=:{range}normal @{macro}=. The advantage of this technique is that all the
macros that can execute will.

*** =~=                                                             :drill:
SCHEDULED: <2022-02-10 Thu>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       9fd4938e-85be-4ed1-9d8d-438c13da7262
:DRILL_LAST_INTERVAL: 506.2267
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-09-22 Tue 10:14]
:END:

vim: <[Switch case of the current character]> with <[~]>

** Tip 69: Append Commands to a Macro

*** Append to a Macro                                               :drill:
SCHEDULED: <2021-06-22 Tue>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       9a008e35-d7e1-467f-be2e-71c40a68dfc7
:DRILL_LAST_INTERVAL: 317.9003
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.444
:DRILL_EASE: 2.04
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-08-08 Sat 09:37]
:END:

vim: <[Append Commands to a Macro]> with <[=q{Uppercase letter}=]>

** Tip 70: Act Upon a Collection of Files

Execute a macro on multiple files in parallel with =:argdo normal @{macro}=.
Execute a macro on multiple files in series by adding the =:next= command at the
end of the macro.
The advantage of the parallel execution is that if an execution fails, it will
still execute for all the other buffers.
The advantage of the series execution is that if an execution fails, the failed
buffer would be immediately in the current view.

** Tip 71: Evaluate an Iterator to Number Items in a List

To insert an incrementing number, record a macro that inserts a variable with
the expression register and then increments it.

Example:
- ~:let i=1~
- ~qa~
- ~I<C-r>=i<CR>)~
- ~<Esc>~
- ~:let i += 1~
- ~q~

** Tip 72: Edit the Contents of a Macro

Edit the content of a Macro by pasting it somewhere with ="{register}p=, editing
it, and finally copying it back into its register with =0"{register}y$=.

** Tip 73: Tune the Case Sensitivity of Search Patterns

Ignore the case when searching with =:set ignorecase=.
Match the case only when searching with an uppercase letter with =:set smartcase=.
Disable case sensitivity by inserting =\c= anywhere in the search pattern.
Force case sensitivity by inserting =\C= anywhere in the search pattern.

Note: For this to work in =evil-mode= you need to set =evil-search-module= to
=evil-search=.

** Tip 74: Use the \v Pattern Switch for Regex Searches

Use the =\v= Pattern Switch in order to use special characters with their
special meaning without having to escape them (eg. =(){}|=...).

** Tip 75: Use the \V Literal Switch for Verbatim Searches

Use the =\V= Pattern Switch in order to use special characters without their
special meaning without having to escape them (eg. =()[]{}|=...).

** Tip 76: Use Parentheses to Capture Submatches

"Capture" a part of a pattern by surrounding it with parentheses. You can then
use the capture with =\{number}= where =number= is the number of the capture
group.
Ignore a capture group by prepending a =%= before the parentheses.

=\_s= matches whitespace and line breaks.

** Tip 77: Stake the Boundaries of a Word

In a pattern, =<= and =>= represent word boundaries. Eg. =\v<the>= or
=\<the\>= will match = the = but not = their =.
Note that in all the other major regex engines, word boundaries are represented
by =\b=.

** Tip 78: Stake the Boundaries of a Match

Use =\zs= and =\ze= to mark the beginning and end of a match. This lets you
capture a subset of the initial match.

** Tip 79: Escape Problem Characters

Escape special characters with the =escape({string}, {chars})= function.
Call this function at the Command Line with ~<C-r>=~.

A simple way to not have to escape the =/= character in a search is to initiate
the search backward with =?=.

** Tip 80: Meet the Search Command

Search forward with =/=.
Search backward with =?=.
Go to the next match with =n=.
Go to the previous match with =N=.

*** gn and gN                                                       :drill:
SCHEDULED: <2021-09-14 Tue>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       818713A5-1F25-424D-B6BB-21C147FCDAE7
:DRILL_LAST_INTERVAL: 247.6422
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 19
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.474
:DRILL_EASE: 1.58
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-09 Sat 08:37]
:END:

vim: <[Select the current or the next/previous search match]> with
<[gn/gN]>

*** C-n and C-p                                                     :drill:
SCHEDULED: <2021-06-20 Sun>
:PROPERTIES:
:ID:       766ce35e-5068-4a29-b31d-c10ec7fd4135
:DRILL_LAST_INTERVAL: 181.0795
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.62
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-12-21 Mon 12:33]
:END:

vim: Scroll through the Ex commands or search history with
<[=<C-n>= and =<C-p>=|| X and Y ]>

** Tip 81: Highlight Search Matches

Highlight search matches with =:set hlsearch=.
Disable highlighting search matches with =:set nohlsearch=.
Disable highlighting search matches for one time with =:nohlsearch=.

** Tip 82: Preview the First Match Before Execution

Show a search preview with =:set incsearch=.

*** Autocomplete Searches with =<C-r><C-w>=                         :drill:
SCHEDULED: <2021-02-12 Fri>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       86cbb447-4956-4d19-8184-266ce634766f
:DRILL_LAST_INTERVAL: 97.2835
:DRILL_REPEATS_SINCE_FAIL: 9
:DRILL_TOTAL_REPEATS: 18
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.111
:DRILL_EASE: 1.3
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-11-07 Sat 11:55]
:END:

vim: <[Autocomplete]> the search field with
<[<C-r><C-a> or <C-r><C-w>||... or ... ]>

** Tip 83: Offset the Cursor to the End of a Search Match

Place the cursor at the end of a search match with =/{pattern}/e=.

** Tip 84: Operate on a Complete Search Match

Use =gn= (or =gN=) to search for a string and select the current or next (or previous) match.
The *Improved Dot Formula* consists in using only one key to make a
change and move

** Tip 85: Create Complex Patterns by Iterating upon Search History

*** =q:=                                                            :drill:
SCHEDULED: <2021-06-11 Fri>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       912b48bc-f078-4ab1-9aed-e050d14c1ab9
:DRILL_LAST_INTERVAL: 305.1519
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.08
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-08-10 Mon 12:17]
:END:

vim: <[Open the Ex Command-Line Window]> with <[=q:=]>

*** =q/=                                                            :drill:
SCHEDULED: <2021-02-08 Mon>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       d01f65ee-fd24-4045-ad30-63d94bcec60f
:DRILL_LAST_INTERVAL: 19.4838
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 24
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 3.292
:DRILL_EASE: 1.16
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-20 Wed 09:20]
:END:

vim: <[Open the Search Command-Line Window]> with <[=q/=]>

** Tip 86: Count the Matches for the Current Pattern

Count the matches for the current pattern with =:vimgrep /[pattern]/ {file}=.
Go to the previous/next match with =N=/=n= or =:cprev= =:cnext=.

** Tip 87: Search for the Current Visual Selection

"Improve" =*='s behavior and introduce a backward counterpart =#=.

#+BEGIN_SRC
xnoremap * :<C-u>call <SID>VSetSearch('/')<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch('?')<CR>?<C-R>=@/<CR><CR>

function! s:VSetSearch(cmdtype)
  let temp = @s
  norm! gv"sy
  let @/ = '\V' . substitute(escape(@s, a:cmdtype.'\'), '\n', '\\n', 'g')
  let @s = temp
endfunction
#+END_SRC

** Tip 88: Meet the Substitute Command

Substitute with =:[range]s[ubstitute]/{pattern}/{string}/[flags]=.
In a substitute command insert the entire matched pattern with =\0= or =&=.
In a substitute command use the previous replacement string with =~=.

** Tip 89: Find and Replace Every Match in a File

Execute the Substitute Command on the whole file with the =%= flag like so
=:%s/{pattern}/{string/}=.
Execute the Substitute Command on the whole line withe the =g= flag like so
=:s/{pattern}/{string/}g=.

** Tip 90: Eyeball Each Substitution

Confirm before doing substitutions with the =c= flag like so
=:s/{pattern}/{string/}c=.

** Tip 91: Reuse the Last Search Pattern

Insert the last search pattern in the Command Prompt with =<C-r>/=.

*** Reuse the Last Search Pattern in a Substitute Command           :drill:
SCHEDULED: <2022-03-06 Sun>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       e9d29d2b-fef0-46d3-9305-3ea3defa17f0
:DRILL_LAST_INTERVAL: 511.9236
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-10-10 Sat 14:08]
:END:

vim: In a Substitute Command <[reuse the last search pattern]> by
<[leaving the pattern field empty]>

** Tip 92: Replace with the Contents of a Register

Avoid typing the replacement field, either by pasting it with
=:s//<C-r>{register}=, or by passing a reference with =:s//\=@{register}=.

** Tip 93: Repeat the Previous Substitute Command

Repeat the previous Substitute Command on the whole file with =g&=.

Repeat the previous Substitute Command with =:&=. Reuse the same flags as the
last Subsitute Command by using =&= to the Substitute Command like so =:&&= or
=:s/{pattern}/{replacement}/&=.

** Tip 94: Rearrange CSV Fields Using Submatches

Rearrange CSV fields using submatches with a search and replace, eg.
=/\v^([^,]*),([^,]*),([^,]*)$= and =:%s//\3,\2,\1=.

** Tip 95: Perform Arithmetic on the Replacement

In a replacement pattern, get a submatch with ~:s//\=submatch({num})/~.
If the submatch returns a number, you can do arithmetic with it,
eg. substract 1: ~:s//\=submatch({num})-1/~.

** Tip 96: Swap Two or More Words

Swap two words (eg. =Man= and =Dog=) like so:
#+BEGIN_SRC
/\v(<man>|<dog>)
:%s//\={"dog":"man","man":"dog"}[submatch(1)]/g
#+END_SRC

** Tip 97: Find and Replace Across Multiple Files

Find and replace across multiple files like so:
#+BEGIN_SRC
/Pragmatic\ze Vim
:vimgrep // **/*.txt
:cfdo %s//Practical/gc
:cfdo update
#+END_SRC

** Tip 98: Meet the Global Command

*** =:global=                                                       :drill:
SCHEDULED: <2021-01-31 Sun>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       2f1368b3-3471-4ec8-8718-c4b192cac6f4
:DRILL_LAST_INTERVAL: 11.5759
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 31
:DRILL_FAILURE_COUNT: 5
:DRILL_AVERAGE_QUALITY: 3.259
:DRILL_EASE: 1.3
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2021-01-19 Tue 08:46]
:END:

vim: <[Execute an Ex Command on lines that match a pattern]> with
<[:g/{pattern}/{cmd}]>

*** =:global!= and =:vglobal=                                       :drill:
SCHEDULED: <2021-09-30 Thu>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       d64e29ef-8461-4366-80c3-df69483a5e05
:DRILL_LAST_INTERVAL: 395.2544
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-08-31 Mon 07:26]
:END:

vim: <[Execute an Ex Command on lines that don't match a pattern]> with
<[=:g!/{pattern}/{cmd}= OR =:v/{pattern}/{cmd}=]>

*** Reuse the Last Search Pattern in a Global Command               :drill:
SCHEDULED: <2022-04-27 Wed>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       dcbe8c23-e109-48ed-b65f-98fd6b60ba92
:DRILL_LAST_INTERVAL: 540.1675
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-11-03 Tue 11:04]
:END:

vim: In a Global Command <[reuse the last search pattern]> by
<[leaving the pattern field blank]>

** Tip 99: Delete Lines Containing a Pattern

Delete lines containing a pattern with =:g/{pattern}/d=, or
delete lines that don't match a pattern with =:v/{pattern}/d=.

** Tip 100: Collect TODO Items in a Register

Collect lines that match a pattern in a register with
=:g/{pattern}/yank {uppercase letter}=.
This can be combined with =:argdo= or =:bufdo= to do the same but over multiple
files.

** Tip 101: Alphabetize the Properties of Each Rule in a CSS File

Sort lines with =:[range]sort=.
Change lines indentation with =:[range]>= or =:[range]<=.

Apply an Ex Command on blocks delimited by a start and a finish pattern with
=:g/{start}/ .,/{finish}/ {cmd}=.
The way it works is the =/{start}/= pattern specifies to the global command
where to consider executing the Ex Command and =.,/{finish}/= is a range applied
to the following Ex Command meaning "from the current line (=.=) to the line
that matches ={finish}=".

** Tip 102: Meet ctags

Generate a tags file with =$ ctags -R .= at the root of a project.

** Tip 103: Configure Vim to Work with ctags

Change the default path of the tags file with ~:set tags={path}~.
Generate the tags file from Vim with =:!ctags -R=.
Generate the tags file when pressing =<f5>= with =:nnoremap <f5> :!ctags -R<CR>=.
Update the tags file each time a file is save with
=:autocmd BufWritePost * call system("ctags -R")=.

** Tip 104: Navigate Keyword Definitions with Vim’s Tag Navigation Commands

Jump back from a Tag Search with =<C-t>=.
Open a tag match list with =g<C-]>=.

*** =<C-]>=                                                         :drill:
SCHEDULED: <2021-06-08 Tue>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       0676996b-20d2-48c6-99b5-259a16872d9a
:DRILL_LAST_INTERVAL: 145.6511
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 12
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.417
:DRILL_EASE: 1.76
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-13 Wed 09:37]
:END:

vim: <[Go to the definition of the keyword under the cursor]> with <[C-]]>

** Tip 105: Compile Code Without Leaving Vim

Compile you program and jump to the first error in the quickfix list with
=:make=.
Go to the previous/next error in the quickfix list with =:cprev= / =:cnext=.

** Tip 106: Browse the Quickfix List

The Quickfix List has a counterpart that is local to the current window, it's
the Location List.
The Quickfix List is global and there can be only one. There can be multiple
Location List, one per window.
All the Location List Ex Commands are prefixed with an =l=:
=:lmake=, =:lnext=, ...

Jump to first item of the Quickfix List with =:cfirst=.
Jump to last item of the Quickfix List with =:clast=.
Jump to first item in next file of the Quickfix List with =:cnfile=.
Jump to last item in previous file of the Quickfix List with =:cpfile=.
Jump to nth item of the Quickfix List with =:cc N=.
Open the quickfix window of the Quickfix List with =:copen=.
Close the quickfix window of the Quickfix List with =:cclose=.
Execute {cmd} on each line listed in the quickfix list of the Quickfix List with
=:cdo {cmd}=.
Execute {cmd} once for each file listed in the quickfix list with =:cfdo {cmd}=.

** Tip 107: Recall Results from a Previous Quickfix List

Use an older or newer Quickfix List with =:colder= / =:cnewer=.

** Tip 108: Customize the External Compiler

Change the command used by =:make= with =:setlocal makeprg={cmd}[\ %]= where =%=
is the current file name.
Change the way errors are parsed with =:setlocal efm\={scanf_format_string}=.

** Tip 109: Call grep Without Leaving Vim

Call grep and let it fill the Quickfix List with =:grep [args] [regex]=.

** Tip 110: Customize the grep Program

Change the program used by the grep command with
~:set grepprg="grep -n $* /dev/null"~.
Change the way the grep output is parsed with
~:set grepformat="%f:%l:%m,%f:%l%m,%f %l%m"~.

** Tip 111: Grep with Vim’s Internal Search Engine

Search for a pattern in some files with
=:vim[grep][!] /{pattern}/[g][j] {file} ...=.
This will populate the Quickfix List. So =:cnext= and =:cprev= can be used.
If the pattern field is blank the last search pattern will be used.
The file list can be =##= which is expanded to the files in the argument list.

** Tip 112: Meet Vim’s Keyword Autocompletion

Complete generic keywords with =<C-n>=.
Complete current buffer keywords with =<C-x><C-n>=.
Complete included file keywords with =<C-x><C-i>=.
Complete tags file keywords with =<C-x><C-]>=.
Complete dictionary keywords with =<C-x><C-k>=.
Complete whole lines with =<C-x><C-l>=.
Complete filenames with =<C-x><C-f>=.
Omni-complete with =<C-x><C-o>=.

** Tip 113: Work with the Autocomplete Pop-Up Menu

Use the next match from the word list (next match) with =<C-n>=.
Use the previous match from the word list (previous match) with =<C-p>=.
Select the next match from the word list with =<Down>=.
Select the previous match from the word list with =<Up>=.
Accept the currently selected match (yes) with =<C-y>=.
Revert to the originally typed text (exit from autocompletion) with =<C-e>=.
Delete one character from current match with =<C-h> (and <BS>)=.
Add one character from current match with =<C-l>=.
Stop completion and insert {char} with ={char}=.

** Tip 114: Understand the Source of Keywords

Complete current buffer keywords with =<C-x><C-n>=.
Complete included file keywords with =<C-x><C-i>=.
Complete tags file keywords with =<C-x><C-]>=.

** Tip 115: Autocomplete Words from the Dictionary

Complete dictionary keywords with =<C-x><C-k>=.
Enable Vim's spell checker with =:set spell=.

** Tip 116: Autocomplete Entire Lines

Complete whole lines with =<C-x><C-l>=.

** Tip 117: Autocomplete Sequences of Words

If you autocomplete something, Vim will remember where it sourced the completion
and subsequent call to the autocompletion will automatically complete from that
place. This lets you autocomplete complete sentences quite easily.

** Tip 118: Autocomplete Filenames

Complete filenames with =<C-x><C-f>=.

** Tip 119: Autocomplete with Context Awareness

Complete with context awareness with =<C-x><C-o>=.

** Tip 120: Spell Check Your Work

Suggest corrections for the current word with ~z=~.
Add the current word to the spell file with =zg=.
Remove the current word from spell file with =zw=.
Revert zg or zw command for the current word =zug=.

*** =]s=                                                            :drill:
SCHEDULED: <2021-03-29 Mon>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       3938d357-ce93-40b6-b587-1e8b5ba9cc18
:DRILL_LAST_INTERVAL: 179.1801
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 13
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.154
:DRILL_EASE: 1.52
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-10-01 Thu 13:08]
:END:

vim: <[Go to the next spelling error]> with <[=]s=]>

*** =[s=                                                            :drill:
SCHEDULED: <2021-01-25 Mon>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       a6e1cab5-af1a-4d07-9bde-116f13405557
:DRILL_LAST_INTERVAL: 5.6557
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 22
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 3.136
:DRILL_EASE: 1.16
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-19 Tue 08:48]
:END:

vim: <[Go to the previous spelling error]> with <[=[s=]>

** Tip 121: Use Alternate Spelling Dictionaries

Change the spelling dictionary used with ~:set spelllang={lang}~.

** Tip 122: Add Words to the Spell File

Add the current word to the spell file with =zg=.
Remove the current word from spell file with =zw=.
Revert zg or zw command for the current word =zug=.

Add a new spellfile with =setlocal spellfile[+]={file}=.
Add the current word to the first spell file with =1zg=.
Add the current word to the second spell file with =2zg=.

** Tip 123: Fix Spelling Errors from Insert Mode

Autocomplete the previous spelling error from Insert Mode with =<C-x><C-s>=.

* Learn Go with Tests
:PROPERTIES:
:SOURCE: https://github.com/quii/learn-go-with-tests https://github.com/quii/learn-go-with-tests/tree/958d89d0810d630b51799fb9bf319e92df80c43e
:END:
:LOGBOOK:
CLOCK: [2020-08-10 Mon 13:48]--[2020-08-10 Mon 15:48] =>  2:00
CLOCK: [2020-08-08 Sat 15:32]--[2020-08-08 Sat 16:32] =>  1:00
CLOCK: [2020-08-08 Sat 13:39]--[2020-08-08 Sat 14:39] =>  1:00
CLOCK: [2020-08-04 Tue 16:40]--[2020-08-04 Tue 18:40] =>  2:00
CLOCK: [2020-08-03 Mon 12:32]--[2020-08-03 Mon 16:32] =>  4:00
CLOCK: [2020-07-28 Tue 16:15]--[2020-07-28 Tue 17:15] =>  1:00
CLOCK: [2020-07-27 Mon 17:28]--[2020-07-27 Mon 19:28] =>  2:00
CLOCK: [2020-07-27 Mon 17:28]--[2020-07-27 Mon 19:28] =>  2:00
CLOCK: [2020-07-11 Sat 15:21]--[2020-07-11 Sun 16:21] =>  1:00
CLOCK: [2020-07-08 Wed 15:48]--[2020-07-08 Wed 16:48] =>  1:00
CLOCK: [2019-10-05 Sat 18:34]--[2019-10-05 Sat 19:34] =>  1:00
CLOCK: [2019-10-05 Sat 16:06]--[2019-10-05 Sat 17:06] =>  1:00
CLOCK: [2019-09-30 Mon 14:55]--[2019-09-30 Mon 17:55] =>  3:00
CLOCK: [2019-09-28 Sat 14:31]--[2019-09-28 Sat 15:31] =>  1:00
CLOCK: [2019-09-23 Mon 19:06]--[2019-09-23 Mon 21:06] =>  2:00
CLOCK: [2019-09-23 Mon 16:10]--[2019-09-23 Mon 17:10] =>  1:00
CLOCK: [2019-09-19 Thu 10:28]--[2019-09-19 Thu 11:28] =>  1:00
:END:

** Hello, World
*** TDD Cycle                                                       :drill:
SCHEDULED: <2021-05-12 Wed>
:PROPERTIES:
:ID:       ede97d9f-a348-4a68-8070-dda21cad8f9d
:DRILL_LAST_INTERVAL: 265.9863
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.2
:DRILL_EASE: 1.66
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-08-19 Wed 09:53]
:END:

cs: The TDD Cycle steps are:
- <[Add a test]>
- <[Run it and see it fail]>
- <[Make it pass with the minimum amount of code]>
- <[Ensure all the other tests pass]>
- <[Refactor based on the current tests]>

*** Test Functions                                                  :drill:
SCHEDULED: <2022-06-05 Sun>
:PROPERTIES:
:ID:       441ea307-1788-416a-a1a9-10a86ef49f4f
:DRILL_LAST_INTERVAL: 515.3081
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.571
:DRILL_EASE: 2.08
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2021-01-06 Wed 19:00]
:END:

go: Test functions need to:
- <[Be called Test...()]>
- <[Be in a ..._test.go file]>

*** Tests are Run With                                              :drill:
SCHEDULED: <2022-06-21 Tue>
:PROPERTIES:
:ID:       999173ea-8172-4be7-aaeb-9be00185c11b
:DRILL_LAST_INTERVAL: 627.5199
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-10-01 Thu 13:07]
:END:

go: Run *Tests* with the command <[go test]>

*** Public Functions Uppercase Letter                               :drill:
SCHEDULED: <2022-06-01 Wed>
:PROPERTIES:
:ID:       1ae8438d-6c64-4334-87d0-bd934219aa7c
:DRILL_LAST_INTERVAL: 608.3101
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-10-01 Thu 13:07]
:END:

go: Public Functions start with <[an Uppercase Letter]>

** Integers
*** Example Functions                                               :drill:
SCHEDULED: <2021-08-01 Sun>
:PROPERTIES:
:ID:       0c4b0d5b-aa72-4edb-989a-54b2c2977456
:DRILL_LAST_INTERVAL: 389.3631
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-07-08 Wed 10:15]
:END:

go: Example functions need to:
- <[Be called Example...()]>
- <[Be in a ..._test.go file]>

** Iteration
*** Benchmark Functions                                             :drill:
SCHEDULED: <2021-08-11 Wed>
:PROPERTIES:
:ID:       c345379b-8bb5-4032-96e4-95bddb901a19
:DRILL_LAST_INTERVAL: 206.9225
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 23
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 3.434
:DRILL_EASE: 1.72
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-16 Sat 09:02]
:END:

go: Benchmark functions need to:
- <[Be called Benchmark...()]>
- <[Be in a ..._test.go file]>

*** Benchmarks are Run With                                         :drill:
SCHEDULED: <2021-10-31 Sun>
:PROPERTIES:
:ID:       3398b200-2043-4802-b08d-5c42b284b92c
:DRILL_LAST_INTERVAL: 463.8327
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-07-24 Fri 13:31]
:END:

go: Run *Benchmarks* with the command <[go test -bench .]>

** Arrays and slices
*** Array Syntax                                                    :drill:
SCHEDULED: <2021-02-08 Mon>
:PROPERTIES:
:ID:       6301ca7c-f041-46b2-ac99-1bb24003ccca
:DRILL_LAST_INTERVAL: 35.7942
:DRILL_REPEATS_SINCE_FAIL: 9
:DRILL_TOTAL_REPEATS: 26
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 3.423
:DRILL_EASE: 1.44
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2021-01-03 Sun 18:04]
:END:

go: Declare an array with =var array <[[SIZE|...]TYPE]>=

*** Slice Syntax                                                    :drill:
SCHEDULED: <2021-12-01 Wed>
:PROPERTIES:
:ID:       dd79a268-2eee-4eb0-a17c-aeb46c901a68
:DRILL_LAST_INTERVAL: 422.3963
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 15
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.534
:DRILL_EASE: 2.24
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-10-05 Mon 10:29]
:END:

go: Declare a slice with =var slice <[[]TYPE]>=

*** len()                                                           :drill:
SCHEDULED: <2022-03-26 Sat>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       54ff64dc-c1a4-42e8-86d3-99708f79eb19
:DRILL_LAST_INTERVAL: 566.9892
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-09-05 Sat 11:51]
:END:

go: function: <[len()]> returns <[the length of an array or slice]>

*** cap()                                                           :drill:
SCHEDULED: <2021-06-12 Sat>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       12efd225-35f6-4fce-810a-62e47ab5e57b
:DRILL_LAST_INTERVAL: 198.5159
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-11-25 Wed 13:03]
:END:

go: <[cap(SLICE)]> returns <[the capacity of the underlying array segment]>

*** append()                                                        :drill:
SCHEDULED: <2021-03-19 Fri>
:PROPERTIES:
:ID:       269c0a37-11ea-42aa-a83c-d409e2c75821
:DRILL_LAST_INTERVAL: 237.0402
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 16
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.14
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-07-25 Sat 08:31]
:END:

go: function: <[append(ARRAY, ELEMENT)]> = returns a new slice with an element appended

*** =range= Clause                                                  :drill:
SCHEDULED: <2021-09-21 Tue>
:PROPERTIES:
:ID:       28b63118-f1c2-41c6-b204-3388d38498d7
:DRILL_LAST_INTERVAL: 349.2799
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.728
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-10-07 Wed 13:58]
:END:

go: Use the =range= clause like so <[for key, value := range ARRAY]>

*** Variadic Function                                               :drill:
SCHEDULED: <2021-03-02 Tue>
:PROPERTIES:
:ID:       b2abe1db-b503-43f2-85e6-1168d305e40b
:DRILL_LAST_INTERVAL: 96.0786
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 21
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.476
:DRILL_EASE: 1.64
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-11-26 Thu 12:40]
:END:

go: Declare a variadic function like so <[func NAME(ARG ...TYPE)]>

*** Tests are Run With                                              :drill:
SCHEDULED: <2022-10-28 Fri>
:PROPERTIES:
:ID:       2e9080e6-0553-4360-96d6-a483d69bc3b0
:DRILL_LAST_INTERVAL: 730.9528
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-10-27 Tue 11:48]
:END:

go: Show *Test Coverages* with the command <[go test -cover]>

*** Array Size                                                      :drill:
SCHEDULED: <2021-07-21 Wed>
:PROPERTIES:
:Source: https://blog.golang.org/slices-intro
:ID:       2b6bf02c-e38e-4593-9b60-36a5c20adad3
:DRILL_LAST_INTERVAL: 228.688
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-12-04 Fri 12:32]
:END:

go: The size of arrays <[is fixed||is fixed or not]>

*** Slices                                                          :drill:
SCHEDULED: <2021-04-13 Tue>
:PROPERTIES:
:Source: https://blog.golang.org/slices-intro
:ID:       6631ad33-695e-4e5c-9d10-399c8a7f8685
:DRILL_LAST_INTERVAL: 129.7356
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-12-04 Fri 12:35]
:END:

go: A slice is <[a pointer to an array segment with its length and total capacity]>

*** Grow Slices                                                     :drill:
SCHEDULED: <2021-04-19 Mon>
:PROPERTIES:
:Source: https://blog.golang.org/slices-intro
:ID:       b1ae0e8f-0cba-407f-b458-2274e8651bec
:DRILL_LAST_INTERVAL: 159.7504
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-11-10 Tue 10:29]
:END:

go: A slice can grow without reallocation if <[the underlying array segment has the capacity]>

*** Slice Example                                                   :drill:
SCHEDULED: <2021-06-23 Wed>
:PROPERTIES:
:ID:       b894aa94-2693-48d2-ad38-25ef624e5157
:DRILL_LAST_INTERVAL: 212.522
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.6
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-11-22 Sun 11:27]
:END:

#+BEGIN_SRC go
array := [4]int{0, 1, 2, 3}
slice := array[1:3]

fmt.Println(array) // <[[0 1 2 3]]>
fmt.Println(slice) // <[[1 2]]>

fmt.Println(len(slice)) // <[2]>
fmt.Println(cap(slice)) // <[3]>
#+END_SRC

*** Slice Index Example                                             :drill:
SCHEDULED: <2021-06-29 Tue>
:PROPERTIES:
:ID:       9d4ebac5-1ce1-418f-92e9-dfeb7fa13e57
:DRILL_LAST_INTERVAL: 219.2012
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-11-22 Sun 11:28]
:END:

#+BEGIN_SRC go
array := [1]int{0}
slice := array[:]

slice[0] = 1

fmt.Println(array) // <[[1]]>
fmt.Println(slice) // <[[1]]>
#+END_SRC

*** Slice append() Example                                          :drill:
SCHEDULED: <2021-01-29 Fri>
:PROPERTIES:
:ID:       6d9ae131-a447-4d58-a695-b25c14dc7a94
:DRILL_LAST_INTERVAL: 45.7186
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-12-14 Mon 09:51]
:END:

#+BEGIN_SRC go
array := [2]int{0, 1}
slice := array[0:1]

slice = append(slice, 2)

fmt.Println(array) // <[[0 2]]>
fmt.Println(slice) // <[[0 2]]>

slice = append(slice, 3)

fmt.Println(array) // <[[0 2]]>
fmt.Println(slice) // <[[0 2 3]]>

slice[0] = 1

fmt.Println(array) // <[[0 2]]>
fmt.Println(slice) // <[[1 2 3]]>
#+END_SRC

** Structs, methods & interfaces
*** Struct Definition Syntax                                        :drill:
SCHEDULED: <2021-01-25 Mon>
:PROPERTIES:
:ID:       ec6bb07b-5cc7-4d89-9fe6-69fa7fd918f8
:DRILL_LAST_INTERVAL: 188.9141
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 13
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.385
:DRILL_EASE: 1.9
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-07-20 Mon 11:35]
:END:

go: Define a *Structure* with:

**** Answer

#+BEGIN_SRC go
type NAME struct {
    FIELD TYPE
    ...
}
#+END_SRC

*** Struct Declaration Syntax                                       :drill:
SCHEDULED: <2021-02-05 Fri>
:PROPERTIES:
:ID:       35f2284d-3775-4863-b821-8ca3cac007e6
:DRILL_LAST_INTERVAL: 238.2308
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.4
:DRILL_EASE: 1.9
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-06-12 Fri 15:23]
:END:

go: Initialize a variable as a struct with ~var struct := <[STRUCT_NAME{FIELD, ...}]>~

*** Method Definition Syntax                                        :drill:
SCHEDULED: <2021-09-30 Thu>
:PROPERTIES:
:ID:       160c8a08-e6cf-4abb-a2d3-cafdf570a6c9
:DRILL_LAST_INTERVAL: 284.1335
:DRILL_REPEATS_SINCE_FAIL: 8
:DRILL_TOTAL_REPEATS: 16
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.438
:DRILL_EASE: 1.72
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-12-20 Sun 12:34]
:END:

go: Define a *Method* with <[func (RECEIVER_NAME RECEIVER_TYPE) METHOD_NAME(ARGS...) RETURN_TYPE]>

*** Interface Definition Syntax                                     :drill:
SCHEDULED: <2022-09-08 Thu>
:PROPERTIES:
:ID:       a53837bf-8c79-41ff-8af3-5f1d648400cd
:DRILL_LAST_INTERVAL: 662.6736
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-11-14 Sat 13:17]
:END:

go: Define an *Interface* with

**** Answer

#+BEGIN_SRC go
type NAME interface {
    METHOD
    ...
}
#+END_SRC

*** Interface Resolution                                            :drill:
SCHEDULED: <2021-06-30 Wed>
:PROPERTIES:
:ID:       7c94897b-a2d5-469d-9e8f-3a406cb6fa76
:DRILL_LAST_INTERVAL: 381.1562
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-06-14 Sun 13:50]
:END:

go: Any structure automatically fits an Interface as long as all <[the specified
methods are implemented]>

*** Table Driven Tests                                              :drill:
SCHEDULED: <2021-06-25 Fri>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       60862745-bde1-46bb-a38a-61479aa04622
:DRILL_LAST_INTERVAL: 381.1271
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-06-09 Tue 11:27]
:END:

go: <[Table Driven Tests]> is a pattern where each <[table entry is a test with
its inputs and expected results]>

*** Kent Beck Quote                                                 :drill:
SCHEDULED: <2021-02-15 Mon>
:PROPERTIES:
:SOURCE: The test speaks to us more clearly, as if it were an assertion of truth, not a sequence of operations
:ID:       d2ed43e9-b02b-47dc-b52e-022a8c3fd4fe
:DRILL_LAST_INTERVAL: 33.3083
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 22
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 3.362
:DRILL_EASE: 1.58
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2021-01-13 Wed 09:43]
:END:

cs: According to *Kent Beck*, tests should be <[Assertions of Truth]> not
<[Sequences of Operations]>

** Pointers & errors
*** Alias a Type                                                    :drill:
SCHEDULED: <2021-04-16 Fri>
:PROPERTIES:
:ID:       2a493929-b718-40bc-bfd7-5933cf30a081
:DRILL_LAST_INTERVAL: 154.7501
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.572
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-11-12 Thu 12:00]
:END:

go: Alias a Type: <[type ALIAS ORIGINAL_TYPE]>

** Maps
*** Map Definition Syntax                                           :drill:
SCHEDULED: <2021-04-04 Sun>
:PROPERTIES:
:ID:       b19670c6-7bc8-4a31-a204-7ba104cee460
:DRILL_LAST_INTERVAL: 151.3125
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-11-04 Wed 08:40]
:END:

go: Define a Map: <[NAME := map[KEY_TYPE]VALUE_TYPE{...}]>

*** Map Lookups Return Values                                       :drill:
SCHEDULED: <2021-03-10 Wed>
:PROPERTIES:
:ID:       acefd8a5-c3d7-4a07-950f-94d7523bb3df
:DRILL_LAST_INTERVAL: 134.5425
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-10-26 Mon 12:46]
:END:

#+BEGIN_SRC go
map := map[int]string{0: "A", 1: "B"}

value, ok := map[1]
value == <["B"]>
ok == <[true]>

value, ok := map[2]
value == <[""]>
ok == <[false]>
#+END_SRC

*** Maps are Reference Types                                        :drill:
SCHEDULED: <2021-05-15 Sat>
:PROPERTIES:
:ID:       2b1cf4e9-88f9-4eb1-85e9-a1c66aff4861
:DRILL_LAST_INTERVAL: 179.8498
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-11-16 Mon 10:26]
:END:

go: Maps are passed by <[reference]>

*** Delete an Element from a Map                                    :drill:
SCHEDULED: <2021-02-05 Fri>
:PROPERTIES:
:ID:       e43836aa-91c6-4527-ae90-1e87db281267
:DRILL_LAST_INTERVAL: 103.5378
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.6
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-10-24 Sat 15:44]
:END:

go: <[delete(MAP, ELEM)]> = Remove ELEM from MAP

** Concurrency
*** Create a Channel                                                :drill:
SCHEDULED: <2021-04-24 Sat>
:PROPERTIES:
:ID:       3b6941bd-7fea-467c-8555-5f0e54624d1f
:DRILL_LAST_INTERVAL: 94.093
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.08
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-20 Wed 09:23]
:END:

go: <[CHANNEL = make(chan TYPE)]> = Create a channel CHANNEL of type TYPE

*** Receive From a Channel                                          :drill:
SCHEDULED: <2021-02-28 Sun>
:PROPERTIES:
:ID:       589951bd-35ad-4b4f-9e5f-452c64ef7599
:DRILL_LAST_INTERVAL: 50.8944
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 12
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.583
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2021-01-08 Fri 09:13]
:END:

go: <[VAR := <-CHANNEL]> = Receive from CHANNEL into VAR

*** Send Into a Channel                                             :drill:
SCHEDULED: <2021-05-19 Wed>
:PROPERTIES:
:ID:       e1102df0-d5be-4030-89ac-b748e74a3eb7
:DRILL_LAST_INTERVAL: 178.3972
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-11-22 Sun 11:29]
:END:

go: <[CHANNEL <- VAR]> = Send VAR into CHANNEL

*** Go Channels Operations are Blocking                             :drill:
SCHEDULED: <2021-05-19 Wed>
:PROPERTIES:
:ID:       9a5aa724-bcde-42a8-9e32-4ad9a1c34b5f
:DRILL_LAST_INTERVAL: 167.2005
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-12-03 Thu 12:11]
:END:

go: Channels operations are <[blocking||blocking or non-blocking]>

*** Goroutine                                                       :drill:
SCHEDULED: <2021-05-03 Mon>
:PROPERTIES:
:ID:       1297fda7-444f-4bc3-a9aa-bd25a345d132
:DRILL_LAST_INTERVAL: 167.635
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-11-16 Mon 10:27]
:END:

go: <[go FUNC()]> = Run FUNC in a goroutine

** Select
*** Defer a Function Call                                           :drill:
SCHEDULED: <2021-05-20 Thu>
:PROPERTIES:
:ID:       8a1c7f09-06de-41a1-a58d-d46eb3c5639e
:DRILL_LAST_INTERVAL: 178.3972
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-11-23 Mon 12:20]
:END:

go: <[defer FUNC()]> = Defer the call of FUNC to the end of the current scope

*** Select                                                          :drill:
SCHEDULED: <2021-02-06 Sat>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       728c09dd-0dcc-4280-8155-aa9d10aa7607
:DRILL_LAST_INTERVAL: 45.7878
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.2
:DRILL_EASE: 1.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-12-22 Tue 13:45]
:END:

go: <[Wait on channel communications]> with <[select]>

* The Go Programming Language
:LOGBOOK:
CLOCK: [2020-11-26 Thu 17:36]--[2020-11-26 Thu 20:36] =>  3:00
CLOCK: [2020-11-23 Mon 13:33]--[2020-11-23 Mon 15:33] =>  2:00
CLOCK: [2020-11-21 Sat 11:33]--[2020-11-21 Sat 14:33] =>  3:00
CLOCK: [2020-11-18 Wed 08:18]--[2020-11-18 Wed 11:18] =>  3:00
CLOCK: [2020-11-15 Sun 17:56]--[2020-11-15 Sun 20:56] =>  3:00
CLOCK: [2020-10-31 Sat 15:32]--[2020-10-31 Sat 17:32] =>  2:00
CLOCK: [2020-10-19 Mon 16:52]--[2020-10-19 Mon 19:52] =>  3:00
CLOCK: [2020-10-18 Sun 19:57]--[2020-10-18 Sun 21:57] =>  2:00
CLOCK: [2020-10-12 Mon 17:47]--[2020-10-12 Mon 18:47] =>  1:00
CLOCK: [2020-10-14 Wed 18:09]--[2020-10-14 Wed 19:09] =>  1:00
CLOCK: [2020-10-04 Sun 18:01]--[2020-10-04 Sun 21:01] =>  3:00
CLOCK: [2020-09-26 Sat 18:52]--[2020-09-26 Sat 19:52] =>  1:00
CLOCK: [2020-08-22 Sat 15:23]--[2020-08-22 Sat 18:23] =>  3:00
CLOCK: [2020-08-19 Wed 14:03]--[2020-08-19 Wed 16:03] =>  2:00
CLOCK: [2020-08-15 Sat 16:37]--[2020-08-15 Sat 17:37] =>  1:00
CLOCK: [2020-08-15 Sat 14:28]--[2020-08-15 Sat 15:28] =>  1:00
:END:

** 3.5 Strings
*** Raw String Literal                                              :drill:
SCHEDULED: <2021-03-01 Mon>
:PROPERTIES:
:ID:       a0c12fe2-d18b-4f88-99c9-c591fc33c855
:DRILL_LAST_INTERVAL: 68.6143
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.25
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-12-22 Tue 13:42]
:END:

go: Create a Raw String Literal with <[`STRING`]>

*** Raw String Literal Interpretation                               :drill:
SCHEDULED: <2021-02-27 Sat>
:PROPERTIES:
:ID:       c73d3529-e046-42ee-ae14-684d5199aa13
:DRILL_LAST_INTERVAL: 66.3733
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-12-23 Wed 11:31]
:END:

go: What is interpreted in a Raw String Literal? <[Nothing]>

*** Looping Over String                                             :drill:
SCHEDULED: <2021-02-20 Sat>
:PROPERTIES:
:ID:       f65c3f80-0ea7-4af9-96be-5da0e9e82908
:DRILL_LAST_INTERVAL: 62.5
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-12-20 Sun 12:32]
:END:

go: =for ... range STRING= will loop on <[each rune]> of STRING

*** String Slice                                                    :drill:
SCHEDULED: <2021-03-21 Sun>
:PROPERTIES:
:ID:       fef7944d-87e6-4743-bcda-5dab6dd5860b
:DRILL_LAST_INTERVAL: 72.9139
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.857
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-07 Thu 09:08]
:END:

go: =STRING[0]= will access the first <[byte]> of STRING

** 4.1 Arrays
*** Compare Arrays                                                  :drill:
SCHEDULED: <2021-02-28 Sun>
:PROPERTIES:
:ID:       d5a368b4-66b5-48b0-9cd3-6212bfb2908b
:DRILL_LAST_INTERVAL: 62.5
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-12-28 Mon 16:32]
:END:

go: Arrays can be compared for equality with <[==]>

** 4.2 Slices
*** Extend a Slice to its Capacity                                  :drill:
SCHEDULED: <2021-02-16 Tue>
:PROPERTIES:
:DRILL_CARD_TYPE: show1cloze
:ID:       74b5eab3-f4ac-4a92-8abe-d023db7bbe45
:DRILL_LAST_INTERVAL: 48.8243
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.25
:DRILL_EASE: 2.08
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-12-29 Tue 12:06]
:END:

go: <[Extend a slice's length to its capacity]> with <[SLICE = SLICE[:cap(SLICE)]]>

*** Append a Slice to a Slice                                       :drill:
SCHEDULED: <2021-02-07 Sun>
:PROPERTIES:
:ID:       1dbfbef7-f301-4f0d-ba8e-273cd6460881
:DRILL_LAST_INTERVAL: 22.6595
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.571
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2021-01-15 Fri 09:14]
:END:

go: Append SLICE2 to SLICE with <[SLICE = append(SLICE, SLICE2...)]>

*** Copy a Slice to Another                                         :drill:
SCHEDULED: <2021-02-12 Fri>
:PROPERTIES:
:ID:       bd64d40e-cdd8-4372-b650-f5eb77691c66
:DRILL_LAST_INTERVAL: 24.21
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.572
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-19 Tue 08:49]
:END:

go: Copy elements of SLICE2 to SLICE with <[copy(SLICE, SLICE2)]>

** 4.3. Maps
*** Accessing an Absent Key in a Map                                :drill:
SCHEDULED: <2021-03-07 Sun>
:PROPERTIES:
:ID:       0152e17a-4518-4306-8184-fd42a95839be
:DRILL_LAST_INTERVAL: 60.525
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.75
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2021-01-05 Tue 19:09]
:END:

go: Accessing an absent key in a map yields <[its zero value]>

*** Check That an Element is in a Map                               :drill:
SCHEDULED: <2021-03-21 Sun>
:PROPERTIES:
:ID:       370c813d-81da-4262-9808-e0b0a61822c1
:DRILL_LAST_INTERVAL: 72.992
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2021-01-07 Thu 09:11]
:END:

go: Check that KEY is in MAP with <[_, ok := MAP[KEY]]>

* How to Design Programs
:LOGBOOK:
CLOCK: [2020-11-15 Sun 13:06]--[2020-11-15 Sun 15:06] =>  2:00
:END:

* Ruby Koans
:LOGBOOK:
CLOCK: [2020-12-18 Fri 09:29]--[2020-12-18 Fri 11:29] =>  2:00
CLOCK: [2020-12-11 Fri 14:24]--[2020-12-11 Fri 16:24] =>  2:00
CLOCK: [2020-12-10 Thu 14:25]--[2020-12-10 Thu 16:25] =>  2:00
CLOCK: [2020-12-09 Wed 14:28]--[2020-12-09 Wed 16:28] =>  2:00
:END:

* The Rust Programming Language
:LOGBOOK:
CLOCK: [2020-12-18 Fri 11:33]--[2020-12-18 Fri 13:33] =>  2:00
:END:
:Source: https://doc.rust-lang.org/book/title-page.html
